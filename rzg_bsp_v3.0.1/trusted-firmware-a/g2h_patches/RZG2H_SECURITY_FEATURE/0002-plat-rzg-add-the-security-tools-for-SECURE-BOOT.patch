From 6664ddd94320707bc1d535201fe8c19492b640dc Mon Sep 17 00:00:00 2001
From: Takunori Otsuka <takunori.otsuka.ur@renesas.com>
Date: Mon, 22 Mar 2021 11:44:12 +0900
Subject: [PATCH 2/2] plat: rzg: add the security tools for SECURE BOOT

This commit adds the security tools for SECURE BOOT

Signed-off-by: Takunori Otsuka <takunori.otsuka.ur@renesas.com>
---
 .../renesas/rzg_security_tools/encrypt_fw/Makefile |   66 +
 .../encrypt_fw/include/cmd_opt.h                   |   32 +
 .../rzg_security_tools/encrypt_fw/include/debug.h  |   59 +
 .../encrypt_fw/include/encrypt.h                   |   18 +
 .../rzg_security_tools/encrypt_fw/src/cmd_opt.c    |   59 +
 .../rzg_security_tools/encrypt_fw/src/encrypt.c    |  142 +++
 .../rzg_security_tools/encrypt_fw/src/main.c       |  203 ++++
 tools/renesas/rzg_security_tools/fiptool/Makefile  |   96 ++
 .../rzg_security_tools/fiptool/src/fiptool.c       | 1258 ++++++++++++++++++++
 .../rzg_security_tools/fiptool/src/fiptool.h       |   56 +
 .../fiptool/src/fiptool_platform.h                 |   31 +
 .../fiptool/src/rzg_firmware_image_package.h       |   91 ++
 .../rzg_security_tools/fiptool/src/tbbr_config.c   |  154 +++
 .../rzg_security_tools/fiptool/src/tbbr_config.h   |   26 +
 tools/renesas/rzg_security_tools/sign_fw/Makefile  |   66 +
 .../rzg_security_tools/sign_fw/include/cmd_opt.h   |   32 +
 .../rzg_security_tools/sign_fw/include/debug.h     |   59 +
 .../rzg_security_tools/sign_fw/include/sign.h      |   24 +
 .../rzg_security_tools/sign_fw/src/cmd_opt.c       |   59 +
 .../renesas/rzg_security_tools/sign_fw/src/main.c  |  253 ++++
 .../renesas/rzg_security_tools/sign_fw/src/sign.c  |  157 +++
 21 files changed, 2941 insertions(+)
 create mode 100644 tools/renesas/rzg_security_tools/encrypt_fw/Makefile
 create mode 100644 tools/renesas/rzg_security_tools/encrypt_fw/include/cmd_opt.h
 create mode 100644 tools/renesas/rzg_security_tools/encrypt_fw/include/debug.h
 create mode 100644 tools/renesas/rzg_security_tools/encrypt_fw/include/encrypt.h
 create mode 100644 tools/renesas/rzg_security_tools/encrypt_fw/src/cmd_opt.c
 create mode 100644 tools/renesas/rzg_security_tools/encrypt_fw/src/encrypt.c
 create mode 100644 tools/renesas/rzg_security_tools/encrypt_fw/src/main.c
 create mode 100644 tools/renesas/rzg_security_tools/fiptool/Makefile
 create mode 100644 tools/renesas/rzg_security_tools/fiptool/src/fiptool.c
 create mode 100644 tools/renesas/rzg_security_tools/fiptool/src/fiptool.h
 create mode 100644 tools/renesas/rzg_security_tools/fiptool/src/fiptool_platform.h
 create mode 100644 tools/renesas/rzg_security_tools/fiptool/src/rzg_firmware_image_package.h
 create mode 100644 tools/renesas/rzg_security_tools/fiptool/src/tbbr_config.c
 create mode 100644 tools/renesas/rzg_security_tools/fiptool/src/tbbr_config.h
 create mode 100644 tools/renesas/rzg_security_tools/sign_fw/Makefile
 create mode 100644 tools/renesas/rzg_security_tools/sign_fw/include/cmd_opt.h
 create mode 100644 tools/renesas/rzg_security_tools/sign_fw/include/debug.h
 create mode 100644 tools/renesas/rzg_security_tools/sign_fw/include/sign.h
 create mode 100644 tools/renesas/rzg_security_tools/sign_fw/src/cmd_opt.c
 create mode 100644 tools/renesas/rzg_security_tools/sign_fw/src/main.c
 create mode 100644 tools/renesas/rzg_security_tools/sign_fw/src/sign.c

diff --git a/tools/renesas/rzg_security_tools/encrypt_fw/Makefile b/tools/renesas/rzg_security_tools/encrypt_fw/Makefile
new file mode 100644
index 0000000..ae529ef
--- /dev/null
+++ b/tools/renesas/rzg_security_tools/encrypt_fw/Makefile
@@ -0,0 +1,66 @@
+#
+# Copyright (c) 2019, Linaro Limited. All rights reserved.
+# Copyright (c) 2021, Renesas Electronics Corporation. All rights reserved.
+#
+# SPDX-License-Identifier: BSD-3-Clause
+#
+
+PROJECT		:= encrypt_fw
+V		?= 0
+BUILD_INFO	?= 1
+DEBUG		:= 0
+BINARY		:= ${PROJECT}${BIN_EXT}
+OPENSSL_DIR	:= /usr
+
+OBJECTS := src/encrypt.o \
+           src/cmd_opt.o \
+           src/main.o
+
+HOSTCCFLAGS := -Wall -std=c99
+
+MAKE_HELPERS_DIRECTORY := ../../../../make_helpers/
+include ${MAKE_HELPERS_DIRECTORY}build_macros.mk
+include ${MAKE_HELPERS_DIRECTORY}build_env.mk
+
+ifeq (${DEBUG},1)
+  HOSTCCFLAGS += -g -O0 -DDEBUG -DLOG_LEVEL=40
+else
+ifeq (${BUILD_INFO},1)
+  HOSTCCFLAGS += -O2 -DLOG_LEVEL=20
+else
+  HOSTCCFLAGS += -O2 -DLOG_LEVEL=10
+endif
+endif
+ifeq (${V},0)
+  Q := @
+else
+  Q :=
+endif
+
+# Make soft links and include from local directory otherwise wrong headers
+# could get pulled in from firmware tree.
+INC_DIR := -I ./include -I ../../../../include/tools_share -I ${OPENSSL_DIR}/include
+LIB_DIR := -L ${OPENSSL_DIR}/lib
+LIB := -lssl -lcrypto
+
+HOSTCC ?= gcc
+
+.PHONY: all clean realclean
+
+all: clean ${BINARY}
+
+${BINARY}: ${OBJECTS} Makefile
+	@echo "  HOSTLD  $@"
+	@echo 'const char build_msg[] = "Built : "__TIME__", "__DATE__;' | \
+                ${HOSTCC} -c ${HOSTCCFLAGS} -xc - -o src/build_msg.o
+	${Q}${HOSTCC} src/build_msg.o ${OBJECTS} ${LIB_DIR} ${LIB} -o $@
+
+%.o: %.c
+	@echo "  HOSTCC  $<"
+	${Q}${HOSTCC} -c ${HOSTCCFLAGS} ${INC_DIR} $< -o $@
+
+clean:
+	$(call SHELL_DELETE_ALL, src/build_msg.o ${OBJECTS})
+
+realclean: clean
+	$(call SHELL_DELETE,${BINARY})
diff --git a/tools/renesas/rzg_security_tools/encrypt_fw/include/cmd_opt.h b/tools/renesas/rzg_security_tools/encrypt_fw/include/cmd_opt.h
new file mode 100644
index 0000000..bd7d31f
--- /dev/null
+++ b/tools/renesas/rzg_security_tools/encrypt_fw/include/cmd_opt.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2015, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2019, Linaro Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef CMD_OPT_H
+#define CMD_OPT_H
+
+#include <getopt.h>
+
+#define CMD_OPT_MAX_NUM			64
+
+/* Supported long command line option types */
+enum {
+	CMD_OPT_FW
+};
+
+/* Structure to define a command line option */
+typedef struct cmd_opt_s {
+	struct option long_opt;
+	const char *help_msg;
+} cmd_opt_t;
+
+/* Exported API*/
+void cmd_opt_add(const cmd_opt_t *cmd_opt);
+const struct option *cmd_opt_get_array(void);
+const char *cmd_opt_get_name(int idx);
+const char *cmd_opt_get_help_msg(int idx);
+
+#endif /* CMD_OPT_H */
diff --git a/tools/renesas/rzg_security_tools/encrypt_fw/include/debug.h b/tools/renesas/rzg_security_tools/encrypt_fw/include/debug.h
new file mode 100644
index 0000000..ee8f1f5
--- /dev/null
+++ b/tools/renesas/rzg_security_tools/encrypt_fw/include/debug.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2015, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef DEBUG_H
+#define DEBUG_H
+
+#include <stdio.h>
+
+/* The log output macros print output to the console. These macros produce
+ * compiled log output only if the LOG_LEVEL defined in the makefile (or the
+ * make command line) is greater or equal than the level required for that
+ * type of log output.
+ * The format expected is the same as for printf(). For example:
+ * INFO("Info %s.\n", "message")    -> INFO:    Info message.
+ * WARN("Warning %s.\n", "message") -> WARNING: Warning message.
+ */
+
+#define LOG_LEVEL_NONE			0
+#define LOG_LEVEL_ERROR			10
+#define LOG_LEVEL_NOTICE		20
+#define LOG_LEVEL_WARNING		30
+#define LOG_LEVEL_INFO			40
+#define LOG_LEVEL_VERBOSE		50
+
+
+#if LOG_LEVEL >= LOG_LEVEL_NOTICE
+# define NOTICE(...)	printf("NOTICE:  " __VA_ARGS__)
+#else
+# define NOTICE(...)
+#endif
+
+#if LOG_LEVEL >= LOG_LEVEL_ERROR
+# define ERROR(...)	printf("ERROR:   " __VA_ARGS__)
+#else
+# define ERROR(...)
+#endif
+
+#if LOG_LEVEL >= LOG_LEVEL_WARNING
+# define WARN(...)	printf("WARNING: " __VA_ARGS__)
+#else
+# define WARN(...)
+#endif
+
+#if LOG_LEVEL >= LOG_LEVEL_INFO
+# define INFO(...)	printf("INFO:    " __VA_ARGS__)
+#else
+# define INFO(...)
+#endif
+
+#if LOG_LEVEL >= LOG_LEVEL_VERBOSE
+# define VERBOSE(...)	printf("VERBOSE: " __VA_ARGS__)
+#else
+# define VERBOSE(...)
+#endif
+
+#endif /* DEBUG_H */
diff --git a/tools/renesas/rzg_security_tools/encrypt_fw/include/encrypt.h b/tools/renesas/rzg_security_tools/encrypt_fw/include/encrypt.h
new file mode 100644
index 0000000..e4b0b46
--- /dev/null
+++ b/tools/renesas/rzg_security_tools/encrypt_fw/include/encrypt.h
@@ -0,0 +1,18 @@
+/*
+ * Copyright (c) 2021, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef ENCRYPT_H
+#define ENCRYPT_H
+
+/* Supported key algorithms */
+enum {
+	KEY_ALG_CBC		/* AES-CBC (default) */
+};
+
+int encrypt_file(int enc_alg, char *key_string,
+		 char *nonce_string, const char *ip_name, const char *op_name);
+
+#endif /* ENCRYPT_H */
diff --git a/tools/renesas/rzg_security_tools/encrypt_fw/src/cmd_opt.c b/tools/renesas/rzg_security_tools/encrypt_fw/src/cmd_opt.c
new file mode 100644
index 0000000..64180d1
--- /dev/null
+++ b/tools/renesas/rzg_security_tools/encrypt_fw/src/cmd_opt.c
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2015, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <cmd_opt.h>
+#include <getopt.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include "debug.h"
+
+/* Command line options */
+static struct option long_opt[CMD_OPT_MAX_NUM+1];
+static const char *help_msg[CMD_OPT_MAX_NUM+1];
+static int num_reg_opt;
+
+void cmd_opt_add(const cmd_opt_t *cmd_opt)
+{
+	assert(cmd_opt != NULL);
+
+	if (num_reg_opt >= CMD_OPT_MAX_NUM) {
+		ERROR("Out of memory. Please increase CMD_OPT_MAX_NUM\n");
+		exit(1);
+	}
+
+	long_opt[num_reg_opt].name = cmd_opt->long_opt.name;
+	long_opt[num_reg_opt].has_arg = cmd_opt->long_opt.has_arg;
+	long_opt[num_reg_opt].flag = 0;
+	long_opt[num_reg_opt].val = cmd_opt->long_opt.val;
+
+	help_msg[num_reg_opt] = cmd_opt->help_msg;
+
+	num_reg_opt++;
+}
+
+const struct option *cmd_opt_get_array(void)
+{
+	return long_opt;
+}
+
+const char *cmd_opt_get_name(int idx)
+{
+	if (idx >= num_reg_opt) {
+		return NULL;
+	}
+
+	return long_opt[idx].name;
+}
+
+const char *cmd_opt_get_help_msg(int idx)
+{
+	if (idx >= num_reg_opt) {
+		return NULL;
+	}
+
+	return help_msg[idx];
+}
diff --git a/tools/renesas/rzg_security_tools/encrypt_fw/src/encrypt.c b/tools/renesas/rzg_security_tools/encrypt_fw/src/encrypt.c
new file mode 100644
index 0000000..a40d256
--- /dev/null
+++ b/tools/renesas/rzg_security_tools/encrypt_fw/src/encrypt.c
@@ -0,0 +1,142 @@
+/*
+ * Copyright (c) 2019, Linaro Limited. All rights reserved.
+ * Author: Sumit Garg <sumit.garg@linaro.org>
+ *
+ * Copyright (c) 2021, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <firmware_encrypted.h>
+#include <openssl/evp.h>
+#include <stdio.h>
+#include <string.h>
+#include "debug.h"
+#include "encrypt.h"
+
+#define BUFFER_SIZE		256
+#define IV_SIZE			16
+#define IV_STRING_SIZE		32
+#define KEY_SIZE		16
+#define KEY_STRING_SIZE		32
+
+static int cbc_encrypt(char *key_string,
+		       char *nonce_string, const char *ip_name,
+		       const char *op_name)
+{
+	FILE *ip_file;
+	FILE *op_file;
+	EVP_CIPHER_CTX *ctx;
+	unsigned char data[BUFFER_SIZE], enc_data[BUFFER_SIZE];
+	unsigned char key[KEY_SIZE], iv[IV_SIZE];
+	int bytes, enc_len = 0, i, j, ret = 0;
+
+	if (strlen(key_string) != KEY_STRING_SIZE) {
+		ERROR("Unsupported key size: %lu\n", strlen(key_string));
+		return -1;
+	}
+
+	for (i = 0, j = 0; i < KEY_SIZE; i++, j += 2) {
+		if (sscanf(&key_string[j], "%02hhx", &key[i]) != 1) {
+			ERROR("Incorrect key format\n");
+			return -1;
+		}
+	}
+
+	if (strlen(nonce_string) != IV_STRING_SIZE) {
+		ERROR("Unsupported IV size: %lu\n", strlen(nonce_string));
+		return -1;
+	}
+
+	for (i = 0, j = 0; i < IV_SIZE; i++, j += 2) {
+		if (sscanf(&nonce_string[j], "%02hhx", &iv[i]) != 1) {
+			ERROR("Incorrect IV format\n");
+			return -1;
+		}
+	}
+
+	ip_file = fopen(ip_name, "rb");
+	if (ip_file == NULL) {
+		ERROR("Cannot read %s\n", ip_name);
+		return -1;
+	}
+
+	op_file = fopen(op_name, "wb");
+	if (op_file == NULL) {
+		ERROR("Cannot write %s\n", op_name);
+		fclose(ip_file);
+		return -1;
+	}
+
+	ctx = EVP_CIPHER_CTX_new();
+	if (ctx == NULL) {
+		ERROR("EVP_CIPHER_CTX_new failed\n");
+		ret = -1;
+		goto out_file;
+	}
+
+	ret = EVP_EncryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, NULL, NULL);
+	if (ret != 1) {
+		ERROR("EVP_EncryptInit_ex failed\n");
+		ret = -1;
+		goto out;
+	}
+	
+	ret = EVP_EncryptInit_ex(ctx, NULL, NULL, key, iv);
+	if (ret != 1) {
+		ERROR("EVP_EncryptInit_ex failed\n");
+		goto out;
+	}
+
+	EVP_CIPHER_CTX_set_padding(ctx, 0);
+
+	while ((bytes = fread(data, 1, BUFFER_SIZE, ip_file)) != 0) {
+		ret = EVP_EncryptUpdate(ctx, enc_data, &enc_len, data, bytes);
+		if (ret != 1) {
+			ERROR("EVP_EncryptUpdate failed\n");
+			ret = -1;
+			goto out;
+		}
+
+		fwrite(enc_data, 1, enc_len, op_file);
+	}
+
+	ret = EVP_EncryptFinal_ex(ctx, enc_data, &enc_len);
+	if (ret != 1) {
+		ERROR("EVP_EncryptFinal_ex failed\n");
+		ret = -1;
+		goto out;
+	}
+
+	fwrite(enc_data, 1, enc_len, op_file);
+	
+	EVP_CIPHER_CTX_cleanup(ctx);
+
+out:
+	EVP_CIPHER_CTX_free(ctx);
+
+out_file:
+	fclose(ip_file);
+	fclose(op_file);
+
+	/*
+	 * EVP_* APIs returns 1 as success but enctool considers
+	 * 0 as success.
+	 */
+	if (ret == 1)
+		ret = 0;
+
+	return ret;
+}
+
+int encrypt_file(int enc_alg, char *key_string,
+		 char *nonce_string, const char *ip_name, const char *op_name)
+{
+	switch (enc_alg) {
+	case KEY_ALG_CBC:
+		return cbc_encrypt(key_string, nonce_string,
+				   ip_name, op_name);
+	default:
+		return -1;
+	}
+}
diff --git a/tools/renesas/rzg_security_tools/encrypt_fw/src/main.c b/tools/renesas/rzg_security_tools/encrypt_fw/src/main.c
new file mode 100644
index 0000000..bc658bd
--- /dev/null
+++ b/tools/renesas/rzg_security_tools/encrypt_fw/src/main.c
@@ -0,0 +1,203 @@
+/*
+ * Copyright (c) 2019, Linaro Limited. All rights reserved.
+ * Author: Sumit Garg <sumit.garg@linaro.org>
+ *
+ * Copyright (c) 2021, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <ctype.h>
+#include <getopt.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+
+#include <openssl/conf.h>
+
+#include "cmd_opt.h"
+#include "debug.h"
+#include "encrypt.h"
+#include "firmware_encrypted.h"
+
+#define NUM_ELEM(x)			((sizeof(x)) / (sizeof(x[0])))
+#define HELP_OPT_MAX_LEN		128
+
+/* Global options */
+
+/* Info messages created in the Makefile */
+extern const char build_msg[];
+
+static char *key_algs_str[] = {
+	[KEY_ALG_CBC] = "cbc",
+};
+
+static void print_help(const char *cmd, const struct option *long_opt)
+{
+	int rem, i = 0;
+	const struct option *opt;
+	char line[HELP_OPT_MAX_LEN];
+	char *p;
+
+	assert(cmd != NULL);
+	assert(long_opt != NULL);
+
+	printf("\n\n");
+	printf("The firmware encryption tool loads the binary image and\n"
+	       "outputs encrypted binary image using an encryption key\n"
+	       "provided as an input hex string.\n");
+	printf("\n");
+	printf("Usage:\n");
+	printf("\t%s [OPTIONS]\n\n", cmd);
+
+	printf("Available options:\n");
+	opt = long_opt;
+	while (opt->name) {
+		p = line;
+		rem = HELP_OPT_MAX_LEN;
+		if (isalpha(opt->val)) {
+			/* Short format */
+			sprintf(p, "-%c,", (char)opt->val);
+			p += 3;
+			rem -= 3;
+		}
+		snprintf(p, rem, "--%s %s", opt->name,
+			 (opt->has_arg == required_argument) ? "<arg>" : "");
+		printf("\t%-32s %s\n", line, cmd_opt_get_help_msg(i));
+		opt++;
+		i++;
+	}
+	printf("\n");
+}
+
+static int get_key_alg(const char *key_alg_str)
+{
+	int i;
+
+	for (i = 0 ; i < NUM_ELEM(key_algs_str) ; i++) {
+		if (strcmp(key_alg_str, key_algs_str[i]) == 0) {
+			return i;
+		}
+	}
+
+	return -1;
+}
+
+/* Common command line options */
+static const cmd_opt_t common_cmd_opt[] = {
+	{
+		{ "help", no_argument, NULL, 'h' },
+		"Print this message and exit"
+	},
+	{
+		{ "key-alg", required_argument, NULL, 'a' },
+		"Encryption key algorithm: 'cbc' (default)"
+	},
+	{
+		{ "key", required_argument, NULL, 'k' },
+		"Encryption key (for supported algorithm)."
+	},
+	{
+		{ "nonce", required_argument, NULL, 'n' },
+		"Nonce or Initialization Vector (for supported algorithm)."
+	},
+	{
+		{ "in", required_argument, NULL, 'i' },
+		"Input filename to be encrypted."
+	},
+	{
+		{ "out", required_argument, NULL, 'o' },
+		"Encrypted output filename."
+	},
+};
+
+int main(int argc, char *argv[])
+{
+	int i, key_alg, ret;
+	int c, opt_idx = 0;
+	const struct option *cmd_opt;
+	char *key = NULL;
+	char *nonce = NULL;
+	char *in_fn = NULL;
+	char *out_fn = NULL;
+
+	NOTICE("Firmware Encryption Tool: %s\n", build_msg);
+
+	/* Set default options */
+	key_alg = KEY_ALG_CBC;
+
+	/* Add common command line options */
+	for (i = 0; i < NUM_ELEM(common_cmd_opt); i++) {
+		cmd_opt_add(&common_cmd_opt[i]);
+	}
+
+	/* Get the command line options populated during the initialization */
+	cmd_opt = cmd_opt_get_array();
+
+	while (1) {
+		/* getopt_long stores the option index here. */
+		c = getopt_long(argc, argv, "a:f:hi:k:n:o:", cmd_opt, &opt_idx);
+
+		/* Detect the end of the options. */
+		if (c == -1) {
+			break;
+		}
+
+		switch (c) {
+		case 'a':
+			key_alg = get_key_alg(optarg);
+			if (key_alg < 0) {
+				ERROR("Invalid key algorithm '%s'\n", optarg);
+				exit(1);
+			}
+			break;
+		case 'k':
+			key = optarg;
+			break;
+		case 'i':
+			in_fn = optarg;
+			break;
+		case 'o':
+			out_fn = optarg;
+			break;
+		case 'n':
+			nonce = optarg;
+			break;
+		case 'h':
+			print_help(argv[0], cmd_opt);
+			exit(0);
+		case '?':
+		default:
+			print_help(argv[0], cmd_opt);
+			exit(1);
+		}
+	}
+
+	if (!key) {
+		ERROR("Key must not be NULL\n");
+		exit(1);
+	}
+
+	if (!nonce) {
+		ERROR("Nonce must not be NULL\n");
+		exit(1);
+	}
+
+	if (!in_fn) {
+		ERROR("Input filename must not be NULL\n");
+		exit(1);
+	}
+
+	if (!out_fn) {
+		ERROR("Output filename must not be NULL\n");
+		exit(1);
+	}
+
+	ret = encrypt_file(key_alg, key, nonce, in_fn, out_fn);
+
+	CRYPTO_cleanup_all_ex_data();
+
+	return ret;
+}
diff --git a/tools/renesas/rzg_security_tools/fiptool/Makefile b/tools/renesas/rzg_security_tools/fiptool/Makefile
new file mode 100644
index 0000000..40d9e2a
--- /dev/null
+++ b/tools/renesas/rzg_security_tools/fiptool/Makefile
@@ -0,0 +1,96 @@
+#
+# Copyright (c) 2014-2018, ARM Limited and Contributors. All rights reserved.
+# Copyright (c) 2021, Renesas Electronics Corporation. All rights reserved.
+#
+# SPDX-License-Identifier: BSD-3-Clause
+#
+
+MAKE_HELPERS_DIRECTORY := ../../../../make_helpers/
+include ${MAKE_HELPERS_DIRECTORY}build_macros.mk
+include ${MAKE_HELPERS_DIRECTORY}build_env.mk
+
+TARGET1 := keyring
+TARGET2 := fw_ipl
+TARGET3 := boot_fw
+
+TARGETS := $(TARGET1) $(TARGET2) $(TARGET3)
+SOURCES := ./src/tbbr_config.c ./src/fiptool.c
+OBJ_DIR := ./obj
+V ?= 0
+
+override CPPFLAGS += -D_GNU_SOURCE -D_XOPEN_SOURCE=700
+
+${TARGET1}: CPPFLAGS += -D_PKG_KEYRING
+${TARGET2}: CPPFLAGS += -D_PKG_FW_IPL
+${TARGET3}: CPPFLAGS += -D_PKG_BOOT_FW
+
+HOSTCCFLAGS := -Wall -Werror -pedantic -std=c99
+ifeq (${DEBUG},1)
+  HOSTCCFLAGS += -g -O0 -DDEBUG
+else
+  HOSTCCFLAGS += -O2
+endif
+LDLIBS := -lcrypto
+
+ifeq (${V},0)
+  Q := @
+else
+  Q :=
+endif
+
+# Process RCAR_SA6_TYPE flag
+ifndef RCAR_SA6_TYPE
+RCAR_SA6_TYPE := 0
+else
+ifeq (${RCAR_SA6_TYPE},0)
+RCAR_SA6_TYPE := 0
+else
+RCAR_SA6_TYPE := 1
+endif
+endif
+$(eval $(call add_define,RCAR_SA6_TYPE))
+
+INCLUDE_PATHS := -I./src -I../include  -I../../../../include/tools_share
+VPATH := $(subst ,:,$(sort $(dir $(SOURCES))))
+
+HOSTCC ?= gcc
+
+.PHONY: all clean
+
+all: ${TARGETS}
+
+define MAKE_TARGET
+$(eval PRG_$1 = fiptool_${1}${BIN_EXT})
+$(eval $(call MAKE_PROGRAM,${PRG_$1},${1}))
+${1}: ${PRG_$1}
+endef
+
+define MAKE_PROGRAM
+$(eval OBJS_$1 = $(call SRCS_TO_OBJS,${SOURCES},${2}))
+$(foreach src,${SOURCES},$(eval $(call MAKE_OBJECT,${src},${2})))
+${1}: ${OBJS_$1}
+	@echo "  HOSTLD  $$@"
+	${Q}${HOSTCC} $${OBJS_$1} -o $$@ ${LDLIBS}
+	@${ECHO_BLANK_LINE}
+	@echo "Built $$@ successfully"
+	@${ECHO_BLANK_LINE}
+$(eval DEL_DATAS += ${1} ${OBJS_$1})
+endef
+
+define MAKE_OBJECT
+$(eval OBJ_$1 = $(call SRCS_TO_OBJS,${1},${2}))
+${OBJ_$1}: ${1}
+	@echo "  HOSTCC  $$<"
+	@if [ ! -d $$(@D) ]; then mkdir -p $$(@D); fi
+	${Q}${HOSTCC} -c $${CPPFLAGS} $${HOSTCCFLAGS} $${INCLUDE_PATHS} $$< -o $$@
+endef
+
+define SRCS_TO_OBJS
+	$(addprefix ${OBJ_DIR}/${2}/,$(notdir $(patsubst %.c,%.o,$(filter %.c,${1}))))
+endef
+
+clean:
+	${Q}echo "  HOSTCC  ${DEL_DATAS}"
+	$(call SHELL_DELETE_ALL, ${DEL_DATAS})
+
+$(foreach tag,${TARGETS},$(eval $(call MAKE_TARGET,${tag})))
diff --git a/tools/renesas/rzg_security_tools/fiptool/src/fiptool.c b/tools/renesas/rzg_security_tools/fiptool/src/fiptool.c
new file mode 100644
index 0000000..97b054e
--- /dev/null
+++ b/tools/renesas/rzg_security_tools/fiptool/src/fiptool.c
@@ -0,0 +1,1258 @@
+/*
+ * Copyright (c) 2016-2017, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2021, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include <assert.h>
+#include <errno.h>
+#include <limits.h>
+#include <stdarg.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "fiptool.h"
+#include "tbbr_config.h"
+
+#define OPT_TOC_ENTRY 0
+#define OPT_PLAT_TOC_FLAGS 1
+#define OPT_ALIGN 2
+
+static int info_cmd(int argc, char *argv[]);
+static void info_usage(void);
+static int create_cmd(int argc, char *argv[]);
+static void create_usage(void);
+static int update_cmd(int argc, char *argv[]);
+static void update_usage(void);
+static int unpack_cmd(int argc, char *argv[]);
+static void unpack_usage(void);
+static int remove_cmd(int argc, char *argv[]);
+static void remove_usage(void);
+static int version_cmd(int argc, char *argv[]);
+static void version_usage(void);
+static int help_cmd(int argc, char *argv[]);
+static void usage(void);
+
+/* Available subcommands. */
+static cmd_t cmds[] = {
+	{ .name = "info",    .handler = info_cmd,    .usage = info_usage    },
+	{ .name = "create",  .handler = create_cmd,  .usage = create_usage  },
+	{ .name = "update",  .handler = update_cmd,  .usage = update_usage  },
+	{ .name = "unpack",  .handler = unpack_cmd,  .usage = unpack_usage  },
+	{ .name = "remove",  .handler = remove_cmd,  .usage = remove_usage  },
+	{ .name = "version", .handler = version_cmd, .usage = version_usage },
+	{ .name = "help",    .handler = help_cmd,    .usage = NULL          },
+};
+
+static image_desc_t *image_desc_head;
+static size_t nr_image_descs;
+static const uuid_t uuid_null;
+static int verbose;
+
+static void vlog(int prio, const char *msg, va_list ap)
+{
+	char *prefix[] = { "DEBUG", "WARN", "ERROR" };
+
+	fprintf(stderr, "%s: ", prefix[prio]);
+	vfprintf(stderr, msg, ap);
+	fputc('\n', stderr);
+}
+
+static void log_dbgx(const char *msg, ...)
+{
+	va_list ap;
+
+	va_start(ap, msg);
+	vlog(LOG_DBG, msg, ap);
+	va_end(ap);
+}
+
+static void log_warnx(const char *msg, ...)
+{
+	va_list ap;
+
+	va_start(ap, msg);
+	vlog(LOG_WARN, msg, ap);
+	va_end(ap);
+}
+
+static void log_err(const char *msg, ...)
+{
+	char buf[512];
+	va_list ap;
+
+	va_start(ap, msg);
+	snprintf(buf, sizeof(buf), "%s: %s", msg, strerror(errno));
+	vlog(LOG_ERR, buf, ap);
+	va_end(ap);
+	exit(1);
+}
+
+static void log_errx(const char *msg, ...)
+{
+	va_list ap;
+
+	va_start(ap, msg);
+	vlog(LOG_ERR, msg, ap);
+	va_end(ap);
+	exit(1);
+}
+
+static char *xstrdup(const char *s, const char *msg)
+{
+	char *d;
+
+	d = strdup(s);
+	if (d == NULL)
+		log_errx("strdup: %s", msg);
+	return d;
+}
+
+static void *xmalloc(size_t size, const char *msg)
+{
+	void *d;
+
+	d = malloc(size);
+	if (d == NULL)
+		log_errx("malloc: %s", msg);
+	return d;
+}
+
+static void *xzalloc(size_t size, const char *msg)
+{
+	return memset(xmalloc(size, msg), 0, size);
+}
+
+static void xfwrite(void *buf, size_t size, FILE *fp, const char *filename)
+{
+	if (fwrite(buf, 1, size, fp) != size)
+		log_errx("Failed to write %s", filename);
+}
+
+static image_desc_t *new_image_desc(const uuid_t *uuid,
+    const char *name, const char *cmdline_name, uint64_t nvm_offset)
+{
+	image_desc_t *desc;
+
+	desc = xzalloc(sizeof(*desc),
+	    "failed to allocate memory for image descriptor");
+	memcpy(&desc->uuid, uuid, sizeof(uuid_t));
+	desc->name = xstrdup(name,
+	    "failed to allocate memory for image name");
+	desc->cmdline_name = xstrdup(cmdline_name,
+	    "failed to allocate memory for image command line name");
+	desc->nvm_offset = nvm_offset;
+	desc->action = DO_UNSPEC;
+	return desc;
+}
+
+static void set_image_desc_action(image_desc_t *desc, int action,
+    const char *arg)
+{
+	assert(desc != NULL);
+
+	if (desc->action_arg != (char *)DO_UNSPEC)
+		free(desc->action_arg);
+	desc->action = action;
+	desc->action_arg = NULL;
+	if (arg != NULL)
+		desc->action_arg = xstrdup(arg,
+		    "failed to allocate memory for argument");
+}
+
+static void free_image_desc(image_desc_t *desc)
+{
+	free(desc->name);
+	free(desc->cmdline_name);
+	free(desc->action_arg);
+	if (desc->image) {
+		free(desc->image->buffer);
+		free(desc->image);
+	}
+	free(desc);
+}
+
+static void add_image_desc(image_desc_t *desc)
+{
+	image_desc_t **p = &image_desc_head;
+
+	while (*p)
+		p = &(*p)->next;
+
+	assert(*p == NULL);
+	*p = desc;
+	nr_image_descs++;
+}
+
+static void free_image_descs(void)
+{
+	image_desc_t *desc = image_desc_head, *tmp;
+
+	while (desc != NULL) {
+		tmp = desc->next;
+		free_image_desc(desc);
+		desc = tmp;
+		nr_image_descs--;
+	}
+	assert(nr_image_descs == 0);
+}
+
+static void fill_image_descs(void)
+{
+	toc_entry_t *toc_entry;
+
+	for (toc_entry = toc_entries;
+	     toc_entry->cmdline_name != NULL;
+	     toc_entry++) {
+		image_desc_t *desc;
+
+		desc = new_image_desc(&toc_entry->uuid,
+		    toc_entry->name,
+		    toc_entry->cmdline_name,
+		    toc_entry->nvm_offset);
+		add_image_desc(desc);
+	}
+}
+
+static image_desc_t *lookup_image_desc_from_uuid(const uuid_t *uuid)
+{
+	image_desc_t *desc;
+
+	for (desc = image_desc_head; desc != NULL; desc = desc->next)
+		if (memcmp(&desc->uuid, uuid, sizeof(uuid_t)) == 0)
+			return desc;
+	return NULL;
+}
+
+static image_desc_t *lookup_image_desc_from_opt(const char *opt)
+{
+	image_desc_t *desc;
+
+	for (desc = image_desc_head; desc != NULL; desc = desc->next)
+		if (strcmp(desc->cmdline_name, opt) == 0)
+			return desc;
+	return NULL;
+}
+
+static void uuid_to_str(char *s, size_t len, const uuid_t *u)
+{
+	assert(len >= (_UUID_STR_LEN + 1));
+
+	snprintf(s, len,
+	    "%02X%02X%02X%02X-%02X%02X-%02X%02X-%04X-%04X%04X%04X",
+	    u->time_low[0], u->time_low[1], u->time_low[2], u->time_low[3],
+	    u->time_mid[0], u->time_mid[1],
+	    u->time_hi_and_version[0], u->time_hi_and_version[1],
+	    (u->clock_seq_hi_and_reserved << 8) | u->clock_seq_low,
+	    (u->node[0] << 8) | u->node[1],
+	    (u->node[2] << 8) | u->node[3],
+	    (u->node[4] << 8) | u->node[5]);
+}
+
+static void uuid_from_str(uuid_t *u, const char *s)
+{
+	int n;
+
+	if (s == NULL)
+		log_errx("UUID cannot be NULL");
+	if (strlen(s) != _UUID_STR_LEN)
+		log_errx("Invalid UUID: %s", s);
+
+	n = sscanf(s,
+	    "%2hhx%2hhx%2hhx%2hhx-%2hhx%2hhx-%2hhx%2hhx-%2hhx%2hhx-%2hhx%2hhx%2hhx%2hhx%2hhx%2hhx",
+	    &u->time_low[0], &u->time_low[1], &u->time_low[2], &u->time_low[3],
+	    &u->time_mid[0], &u->time_mid[1],
+	    &u->time_hi_and_version[0], &u->time_hi_and_version[1],
+	    &u->clock_seq_hi_and_reserved, &u->clock_seq_low,
+	    &u->node[0], &u->node[1],
+	    &u->node[2], &u->node[3],
+	    &u->node[4], &u->node[5]);
+	/*
+	 * Given the format specifier above, we expect 16 items to be scanned
+	 * for a properly formatted UUID.
+	 */
+	if (n != 16)
+		log_errx("Invalid UUID: %s", s);
+}
+
+static void addr_from_str(uint64_t *a, const char *s)
+{
+	unsigned long long addr;
+	char *endptr;
+
+	if (s == NULL)
+		log_errx("NVM address cannot be NULL");
+
+	errno = 0;
+	addr = strtoull(s, &endptr, 16);
+	if (*endptr != '\0' || errno != 0)
+		log_errx("Invalid NVM address: %s", s);
+
+	*a = addr;
+}
+
+static int parse_fip(const char *filename, fip_toc_header_t *toc_header_out)
+{
+	struct BLD_PLAT_STAT st;
+	FILE *fp;
+	char *buf, *bufend;
+	fip_toc_header_t *toc_header;
+	fip_toc_entry_t *toc_entry;
+	int terminated = 0;
+
+	fp = fopen(filename, "rb");
+	if (fp == NULL)
+		log_err("fopen %s", filename);
+
+	if (fstat(fileno(fp), &st) == -1)
+		log_err("fstat %s", filename);
+
+	buf = xmalloc(st.st_size, "failed to load file into memory");
+	if (fread(buf, 1, st.st_size, fp) != st.st_size)
+		log_errx("Failed to read %s", filename);
+	bufend = buf + st.st_size;
+	fclose(fp);
+
+	if (st.st_size < sizeof(fip_toc_header_t))
+		log_errx("FIP %s is truncated", filename);
+
+	toc_header = (fip_toc_header_t *)buf;
+	toc_entry = (fip_toc_entry_t *)(toc_header + 1);
+
+	if (toc_header->name != TOC_HEADER_NAME)
+		log_errx("%s is not a FIP file", filename);
+
+	/* Return the ToC header if the caller wants it. */
+	if (toc_header_out != NULL)
+		*toc_header_out = *toc_header;
+
+	/* Walk through each ToC entry in the file. */
+	while ((char *)toc_entry + sizeof(*toc_entry) - 1 < bufend) {
+		image_t *image;
+		image_desc_t *desc;
+
+		/* Found the ToC terminator, we are done. */
+		if (memcmp(&toc_entry->uuid, &uuid_null, sizeof(uuid_t)) == 0) {
+			terminated = 1;
+			break;
+		}
+
+		/*
+		 * Build a new image out of the ToC entry and add it to the
+		 * table of images.
+		 */
+		image = xzalloc(sizeof(*image),
+		    "failed to allocate memory for image");
+		image->toc_e = *toc_entry;
+		image->buffer = xmalloc(toc_entry->size,
+		    "failed to allocate image buffer, is FIP file corrupted?");
+		/* Overflow checks before memory copy. */
+		if (toc_entry->size > (uint64_t)-1 - toc_entry->offset_address)
+			log_errx("FIP %s is corrupted", filename);
+		if (toc_entry->size + toc_entry->offset_address > st.st_size)
+			log_errx("FIP %s is corrupted", filename);
+
+		memcpy(image->buffer, buf + toc_entry->offset_address,
+		    toc_entry->size);
+
+		/* If this is an unknown image, create a descriptor for it. */
+		desc = lookup_image_desc_from_uuid(&toc_entry->uuid);
+		if (desc == NULL) {
+			char name[_UUID_STR_LEN + 1], filename[PATH_MAX];
+
+			uuid_to_str(name, sizeof(name), &toc_entry->uuid);
+			snprintf(filename, sizeof(filename), "%s%s",
+			    name, ".bin");
+			desc = new_image_desc(&toc_entry->uuid, name, "blob", toc_entry->nvm_offset);
+			desc->action = DO_UNPACK;
+			desc->action_arg = xstrdup(filename,
+			    "failed to allocate memory for blob filename");
+			add_image_desc(desc);
+		}
+
+		assert(desc->image == NULL);
+		desc->image = image;
+
+		toc_entry++;
+	}
+
+	if (terminated == 0)
+		log_errx("FIP %s does not have a ToC terminator entry",
+		    filename);
+	free(buf);
+	return 0;
+}
+
+static image_t *read_image_from_file(const uuid_t *uuid, const char *filename, uint64_t nvm_offset)
+{
+	struct BLD_PLAT_STAT st;
+	image_t *image;
+	FILE *fp;
+
+	assert(uuid != NULL);
+	assert(filename != NULL);
+
+	fp = fopen(filename, "rb");
+	if (fp == NULL)
+		log_err("fopen %s", filename);
+
+	if (fstat(fileno(fp), &st) == -1)
+		log_errx("fstat %s", filename);
+
+	image = xzalloc(sizeof(*image), "failed to allocate memory for image");
+	image->toc_e.uuid = *uuid;
+	image->toc_e.nvm_offset = nvm_offset;
+	image->buffer = xmalloc(st.st_size, "failed to allocate image buffer");
+	if (fread(image->buffer, 1, st.st_size, fp) != st.st_size)
+		log_errx("Failed to read %s", filename);
+	image->toc_e.size = st.st_size;
+
+	fclose(fp);
+	return image;
+}
+
+static int write_image_to_file(const image_t *image, const char *filename)
+{
+	FILE *fp;
+
+	fp = fopen(filename, "wb");
+	if (fp == NULL)
+		log_err("fopen");
+	xfwrite(image->buffer, image->toc_e.size, fp, filename);
+	fclose(fp);
+	return 0;
+}
+
+static struct option *add_opt(struct option *opts, size_t *nr_opts,
+    const char *name, int has_arg, int val)
+{
+	opts = realloc(opts, (*nr_opts + 1) * sizeof(*opts));
+	if (opts == NULL)
+		log_err("realloc");
+	opts[*nr_opts].name = name;
+	opts[*nr_opts].has_arg = has_arg;
+	opts[*nr_opts].flag = NULL;
+	opts[*nr_opts].val = val;
+	++*nr_opts;
+	return opts;
+}
+
+static struct option *fill_common_opts(struct option *opts, size_t *nr_opts,
+    int has_arg)
+{
+	image_desc_t *desc;
+
+	for (desc = image_desc_head; desc != NULL; desc = desc->next)
+		opts = add_opt(opts, nr_opts, desc->cmdline_name, has_arg,
+		    OPT_TOC_ENTRY);
+	return opts;
+}
+
+static void md_print(const unsigned char *md, size_t len)
+{
+	size_t i;
+
+	for (i = 0; i < len; i++)
+		printf("%02x", md[i]);
+}
+
+static int info_cmd(int argc, char *argv[])
+{
+	image_desc_t *desc;
+	fip_toc_header_t toc_header;
+
+	if (argc != 2)
+		info_usage();
+	argc--, argv++;
+
+	parse_fip(argv[0], &toc_header);
+
+	if (verbose) {
+		log_dbgx("toc_header[name]: 0x%llX",
+		    (unsigned long long)toc_header.name);
+		log_dbgx("toc_header[serial_number]: 0x%llX",
+		    (unsigned long long)toc_header.serial_number);
+		log_dbgx("toc_header[flags]: 0x%llX",
+		    (unsigned long long)toc_header.flags);
+	}
+
+	for (desc = image_desc_head; desc != NULL; desc = desc->next) {
+		image_t *image = desc->image;
+
+		if (image == NULL)
+			continue;
+		printf("%s: offset=0x%llX, size=0x%llX, nvm=0x%llX, cmdline=\"--%s\"",
+		       desc->name,
+		       (unsigned long long)image->toc_e.offset_address,
+		       (unsigned long long)image->toc_e.size,
+		       (unsigned long long)image->toc_e.nvm_offset,
+		       desc->cmdline_name);
+#ifndef _MSC_VER	/* We don't have SHA256 for Visual Studio. */
+		if (verbose) {
+			unsigned char md[SHA256_DIGEST_LENGTH];
+
+			SHA256(image->buffer, image->toc_e.size, md);
+			printf(", sha256=");
+			md_print(md, sizeof(md));
+		}
+#endif
+		putchar('\n');
+	}
+
+	return 0;
+}
+
+static void info_usage(void)
+{
+	printf("fiptool info FIP_FILENAME\n");
+	exit(1);
+}
+
+static int pack_images(const char *filename, uint64_t toc_flags, unsigned long align)
+{
+	FILE *fp;
+	image_desc_t *desc;
+	fip_toc_header_t *toc_header;
+	fip_toc_entry_t *toc_entry;
+	char *buf;
+	uint64_t entry_offset, buf_size, payload_size = 0, pad_size;
+	size_t nr_images = 0;
+
+	for (desc = image_desc_head; desc != NULL; desc = desc->next)
+		if (desc->image != NULL)
+			nr_images++;
+
+	buf_size = sizeof(fip_toc_header_t) +
+	    sizeof(fip_toc_entry_t) * (nr_images + 1);
+	buf = calloc(1, buf_size);
+	if (buf == NULL)
+		log_err("calloc");
+
+	/* Build up header and ToC entries from the image table. */
+	toc_header = (fip_toc_header_t *)buf;
+	toc_header->name = TOC_HEADER_NAME;
+	toc_header->serial_number = TOC_HEADER_SERIAL_NUMBER;
+	toc_header->flags = toc_flags;
+
+	toc_entry = (fip_toc_entry_t *)(toc_header + 1);
+
+	entry_offset = buf_size;
+	for (desc = image_desc_head; desc != NULL; desc = desc->next) {
+		image_t *image = desc->image;
+
+		if (image == NULL)
+			continue;
+		payload_size += image->toc_e.size;
+		entry_offset = (entry_offset + align - 1) & ~(align - 1);
+		image->toc_e.offset_address = entry_offset;
+		*toc_entry++ = image->toc_e;
+		entry_offset += image->toc_e.size;
+	}
+
+	/*
+	 * Append a null uuid entry to mark the end of ToC entries.
+	 * NOTE the offset address for the last toc_entry must match the fip
+	 * size.
+	 */
+	memset(toc_entry, 0, sizeof(*toc_entry));
+	toc_entry->offset_address = (entry_offset + align - 1) & ~(align - 1);
+
+	/* Generate the FIP file. */
+	fp = fopen(filename, "wb");
+	if (fp == NULL)
+		log_err("fopen %s", filename);
+
+	if (verbose)
+		log_dbgx("Metadata size: %zu bytes", buf_size);
+
+	xfwrite(buf, buf_size, fp, filename);
+
+	if (verbose)
+		log_dbgx("Payload size: %zu bytes", payload_size);
+
+	for (desc = image_desc_head; desc != NULL; desc = desc->next) {
+		image_t *image = desc->image;
+
+		if (image == NULL)
+			continue;
+		if (fseek(fp, image->toc_e.offset_address, SEEK_SET))
+			log_errx("Failed to set file position");
+
+		xfwrite(image->buffer, image->toc_e.size, fp, filename);
+	}
+
+	if (fseek(fp, entry_offset, SEEK_SET))
+		log_errx("Failed to set file position");
+
+	pad_size = toc_entry->offset_address - entry_offset;
+	while (pad_size--)
+		fputc(0x0, fp);
+
+	free(buf);
+	fclose(fp);
+	return 0;
+}
+
+/*
+ * This function is shared between the create and update subcommands.
+ * The difference between the two subcommands is that when the FIP file
+ * is created, the parsing of an existing FIP is skipped.  This results
+ * in update_fip() creating the new FIP file from scratch because the
+ * internal image table is not populated.
+ */
+static void update_fip(void)
+{
+	image_desc_t *desc;
+
+	/* Add or replace images in the FIP file. */
+	for (desc = image_desc_head; desc != NULL; desc = desc->next) {
+		image_t *image;
+
+		if (desc->action != DO_PACK)
+			continue;
+
+		image = read_image_from_file(&desc->uuid,
+		    desc->action_arg, desc->nvm_offset);
+		if (desc->image != NULL) {
+			if (verbose) {
+				log_dbgx("Replacing %s with %s",
+				    desc->cmdline_name,
+				    desc->action_arg);
+			}
+			free(desc->image);
+			desc->image = image;
+		} else {
+			if (verbose)
+				log_dbgx("Adding image %s",
+				    desc->action_arg);
+			desc->image = image;
+		}
+	}
+}
+
+static void parse_plat_toc_flags(const char *arg, unsigned long long *toc_flags)
+{
+	unsigned long long flags;
+	char *endptr;
+
+	errno = 0;
+	flags = strtoull(arg, &endptr, 16);
+	if (*endptr != '\0' || flags > UINT16_MAX || errno != 0)
+		log_errx("Invalid platform ToC flags: %s", arg);
+	/* Platform ToC flags is a 16-bit field occupying bits [32-47]. */
+	*toc_flags |= flags << 32;
+}
+
+static int is_power_of_2(unsigned long x)
+{
+	return x && !(x & (x - 1));
+}
+
+static unsigned long get_image_align(char *arg)
+{
+	char *endptr;
+	unsigned long align;
+
+	errno = 0;
+	align = strtoul(arg, &endptr, 0);
+	if (*endptr != '\0' || !is_power_of_2(align) || errno != 0)
+		log_errx("Invalid alignment: %s", arg);
+
+	return align;
+}
+
+static void parse_blob_opt(char *arg, uuid_t *uuid, char *filename, size_t len, uint64_t *nvm_offset)
+{
+	char *p;
+
+	for (p = strtok(arg, ","); p != NULL; p = strtok(NULL, ",")) {
+		if (strncmp(p, "uuid=", strlen("uuid=")) == 0) {
+			p += strlen("uuid=");
+			uuid_from_str(uuid, p);
+		} else if (strncmp(p, "file=", strlen("file=")) == 0) {
+			p += strlen("file=");
+			snprintf(filename, len, "%s", p);
+		} else if (strncmp(p, "file=", strlen("nvm=")) == 0) {
+			p += strlen("nvm=");
+			addr_from_str(nvm_offset, p);
+		}
+	}
+}
+
+static int create_cmd(int argc, char *argv[])
+{
+	struct option *opts = NULL;
+	size_t nr_opts = 0;
+	unsigned long long toc_flags = 0;
+	unsigned long align = 1;
+
+	if (argc < 2)
+		create_usage();
+
+	opts = fill_common_opts(opts, &nr_opts, required_argument);
+	opts = add_opt(opts, &nr_opts, "plat-toc-flags", required_argument,
+	    OPT_PLAT_TOC_FLAGS);
+	opts = add_opt(opts, &nr_opts, "align", required_argument, OPT_ALIGN);
+	opts = add_opt(opts, &nr_opts, "blob", required_argument, 'b');
+	opts = add_opt(opts, &nr_opts, NULL, 0, 0);
+
+	while (1) {
+		int c, opt_index = 0;
+
+		c = getopt_long(argc, argv, "b:", opts, &opt_index);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case OPT_TOC_ENTRY: {
+			image_desc_t *desc;
+
+			desc = lookup_image_desc_from_opt(opts[opt_index].name);
+			set_image_desc_action(desc, DO_PACK, optarg);
+			break;
+		}
+		case OPT_PLAT_TOC_FLAGS:
+			parse_plat_toc_flags(optarg, &toc_flags);
+			break;
+		case OPT_ALIGN:
+			align = get_image_align(optarg);
+			break;
+		case 'b': {
+			char name[_UUID_STR_LEN + 1];
+			char filename[PATH_MAX] = { 0 };
+			uuid_t uuid = uuid_null;
+			uint64_t nvm_offset = 0xFFFFFFFF;
+			image_desc_t *desc;
+
+			parse_blob_opt(optarg, &uuid,
+			    filename, sizeof(filename), &nvm_offset);
+
+			if (memcmp(&uuid, &uuid_null, sizeof(uuid_t)) == 0 ||
+			    filename[0] == '\0')
+				create_usage();
+
+			desc = lookup_image_desc_from_uuid(&uuid);
+			if (desc == NULL) {
+				uuid_to_str(name, sizeof(name), &uuid);
+				desc = new_image_desc(&uuid, name, "blob", nvm_offset);
+				add_image_desc(desc);
+			}
+			set_image_desc_action(desc, DO_PACK, filename);
+			break;
+		}
+		default:
+			create_usage();
+		}
+	}
+	argc -= optind;
+	argv += optind;
+	free(opts);
+
+	if (argc == 0)
+		create_usage();
+
+	update_fip();
+
+	pack_images(argv[0], toc_flags, align);
+	return 0;
+}
+
+static void create_usage(void)
+{
+	toc_entry_t *toc_entry = toc_entries;
+
+	printf("fiptool create [opts] FIP_FILENAME\n");
+	printf("\n");
+	printf("Options:\n");
+	printf("  --align <value>\t\tEach image is aligned to <value> (default: 1).\n");
+	printf("  --blob uuid=...,file=...,nvm=...\tAdd an image with the given UUID pointed to by file.\n");
+	printf("  --plat-toc-flags <value>\t16-bit platform specific flag field occupying bits 32-47 in 64-bit ToC header.\n");
+	printf("\n");
+	printf("Specific images are packed with the following options:\n");
+	for (; toc_entry->cmdline_name != NULL; toc_entry++)
+		printf("  --%-16s FILENAME\t%s\n", toc_entry->cmdline_name,
+		    toc_entry->name);
+	exit(1);
+}
+
+static int update_cmd(int argc, char *argv[])
+{
+	struct option *opts = NULL;
+	size_t nr_opts = 0;
+	char outfile[PATH_MAX] = { 0 };
+	fip_toc_header_t toc_header = { 0 };
+	unsigned long long toc_flags = 0;
+	unsigned long align = 1;
+	int pflag = 0;
+
+	if (argc < 2)
+		update_usage();
+
+	opts = fill_common_opts(opts, &nr_opts, required_argument);
+	opts = add_opt(opts, &nr_opts, "align", required_argument, OPT_ALIGN);
+	opts = add_opt(opts, &nr_opts, "blob", required_argument, 'b');
+	opts = add_opt(opts, &nr_opts, "out", required_argument, 'o');
+	opts = add_opt(opts, &nr_opts, "plat-toc-flags", required_argument,
+	    OPT_PLAT_TOC_FLAGS);
+	opts = add_opt(opts, &nr_opts, NULL, 0, 0);
+
+	while (1) {
+		int c, opt_index = 0;
+
+		c = getopt_long(argc, argv, "b:o:", opts, &opt_index);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case OPT_TOC_ENTRY: {
+			image_desc_t *desc;
+
+			desc = lookup_image_desc_from_opt(opts[opt_index].name);
+			set_image_desc_action(desc, DO_PACK, optarg);
+			break;
+		}
+		case OPT_PLAT_TOC_FLAGS:
+			parse_plat_toc_flags(optarg, &toc_flags);
+			pflag = 1;
+			break;
+		case 'b': {
+			char name[_UUID_STR_LEN + 1];
+			char filename[PATH_MAX] = { 0 };
+			uuid_t uuid = uuid_null;
+			uint64_t nvm_offset = 0xFFFFFFFF;
+			image_desc_t *desc;
+
+			parse_blob_opt(optarg, &uuid,
+			    filename, sizeof(filename), &nvm_offset);
+
+			if (memcmp(&uuid, &uuid_null, sizeof(uuid_t)) == 0 ||
+			    filename[0] == '\0')
+				update_usage();
+
+			desc = lookup_image_desc_from_uuid(&uuid);
+			if (desc == NULL) {
+				uuid_to_str(name, sizeof(name), &uuid);
+				desc = new_image_desc(&uuid, name, "blob", nvm_offset);
+				add_image_desc(desc);
+			}
+			set_image_desc_action(desc, DO_PACK, filename);
+			break;
+		}
+		case OPT_ALIGN:
+			align = get_image_align(optarg);
+			break;
+		case 'o':
+			snprintf(outfile, sizeof(outfile), "%s", optarg);
+			break;
+		default:
+			update_usage();
+		}
+	}
+	argc -= optind;
+	argv += optind;
+	free(opts);
+
+	if (argc == 0)
+		update_usage();
+
+	if (outfile[0] == '\0')
+		snprintf(outfile, sizeof(outfile), "%s", argv[0]);
+
+	if (access(argv[0], F_OK) == 0)
+		parse_fip(argv[0], &toc_header);
+
+	if (pflag)
+		toc_header.flags &= ~(0xffffULL << 32);
+	toc_flags = (toc_header.flags |= toc_flags);
+
+	update_fip();
+
+	pack_images(outfile, toc_flags, align);
+	return 0;
+}
+
+static void update_usage(void)
+{
+	toc_entry_t *toc_entry = toc_entries;
+
+	printf("fiptool update [opts] FIP_FILENAME\n");
+	printf("\n");
+	printf("Options:\n");
+	printf("  --align <value>\t\tEach image is aligned to <value> (default: 1).\n");
+	printf("  --blob uuid=...,file=...,nvm=...\tAdd or update an image with the given UUID pointed to by file.\n");
+	printf("  --out FIP_FILENAME\t\tSet an alternative output FIP file.\n");
+	printf("  --plat-toc-flags <value>\t16-bit platform specific flag field occupying bits 32-47 in 64-bit ToC header.\n");
+	printf("\n");
+	printf("Specific images are packed with the following options:\n");
+	for (; toc_entry->cmdline_name != NULL; toc_entry++)
+		printf("  --%-16s FILENAME\t%s\n", toc_entry->cmdline_name,
+		    toc_entry->name);
+	exit(1);
+}
+
+static int unpack_cmd(int argc, char *argv[])
+{
+	struct option *opts = NULL;
+	size_t nr_opts = 0;
+	char outdir[PATH_MAX] = { 0 };
+	image_desc_t *desc;
+	int fflag = 0;
+	int unpack_all = 1;
+
+	if (argc < 2)
+		unpack_usage();
+
+	opts = fill_common_opts(opts, &nr_opts, required_argument);
+	opts = add_opt(opts, &nr_opts, "blob", required_argument, 'b');
+	opts = add_opt(opts, &nr_opts, "force", no_argument, 'f');
+	opts = add_opt(opts, &nr_opts, "out", required_argument, 'o');
+	opts = add_opt(opts, &nr_opts, NULL, 0, 0);
+
+	while (1) {
+		int c, opt_index = 0;
+
+		c = getopt_long(argc, argv, "b:fo:", opts, &opt_index);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case OPT_TOC_ENTRY: {
+			image_desc_t *desc;
+
+			desc = lookup_image_desc_from_opt(opts[opt_index].name);
+			set_image_desc_action(desc, DO_UNPACK, optarg);
+			unpack_all = 0;
+			break;
+		}
+		case 'b': {
+			char name[_UUID_STR_LEN + 1];
+			char filename[PATH_MAX] = { 0 };
+			uuid_t uuid = uuid_null;
+			uint64_t nvm_offset = 0xFFFFFFFF;
+			image_desc_t *desc;
+
+			parse_blob_opt(optarg, &uuid,
+			    filename, sizeof(filename), &nvm_offset);
+
+			if (memcmp(&uuid, &uuid_null, sizeof(uuid_t)) == 0 ||
+			    filename[0] == '\0')
+				unpack_usage();
+
+			desc = lookup_image_desc_from_uuid(&uuid);
+			if (desc == NULL) {
+				uuid_to_str(name, sizeof(name), &uuid);
+				desc = new_image_desc(&uuid, name, "blob", nvm_offset);
+				add_image_desc(desc);
+			}
+			set_image_desc_action(desc, DO_UNPACK, filename);
+			unpack_all = 0;
+			break;
+		}
+		case 'f':
+			fflag = 1;
+			break;
+		case 'o':
+			snprintf(outdir, sizeof(outdir), "%s", optarg);
+			break;
+		default:
+			unpack_usage();
+		}
+	}
+	argc -= optind;
+	argv += optind;
+	free(opts);
+
+	if (argc == 0)
+		unpack_usage();
+
+	parse_fip(argv[0], NULL);
+
+	if (outdir[0] != '\0')
+		if (chdir(outdir) == -1)
+			log_err("chdir %s", outdir);
+
+	/* Unpack all specified images. */
+	for (desc = image_desc_head; desc != NULL; desc = desc->next) {
+		char file[PATH_MAX];
+		image_t *image = desc->image;
+
+		if (!unpack_all && desc->action != DO_UNPACK)
+			continue;
+
+		/* Build filename. */
+		if (desc->action_arg == NULL)
+			snprintf(file, sizeof(file), "%s.bin",
+			    desc->cmdline_name);
+		else
+			snprintf(file, sizeof(file), "%s",
+			    desc->action_arg);
+
+		if (image == NULL) {
+			if (!unpack_all)
+				log_warnx("%s does not exist in %s",
+				    file, argv[0]);
+			continue;
+		}
+
+		if (access(file, F_OK) != 0 || fflag) {
+			if (verbose)
+				log_dbgx("Unpacking %s", file);
+			write_image_to_file(image, file);
+		} else {
+			log_warnx("File %s already exists, use --force to overwrite it",
+			    file);
+		}
+	}
+
+	return 0;
+}
+
+static void unpack_usage(void)
+{
+	toc_entry_t *toc_entry = toc_entries;
+
+	printf("fiptool unpack [opts] FIP_FILENAME\n");
+	printf("\n");
+	printf("Options:\n");
+	printf("  --blob uuid=...,file=...\tUnpack an image with the given UUID to file.\n");
+	printf("  --force\t\t\tIf the output file already exists, use --force to overwrite it.\n");
+	printf("  --out path\t\t\tSet the output directory path.\n");
+	printf("\n");
+	printf("Specific images are unpacked with the following options:\n");
+	for (; toc_entry->cmdline_name != NULL; toc_entry++)
+		printf("  --%-16s FILENAME\t%s\n", toc_entry->cmdline_name,
+		    toc_entry->name);
+	printf("\n");
+	printf("If no options are provided, all images will be unpacked.\n");
+	exit(1);
+}
+
+static int remove_cmd(int argc, char *argv[])
+{
+	struct option *opts = NULL;
+	size_t nr_opts = 0;
+	char outfile[PATH_MAX] = { 0 };
+	fip_toc_header_t toc_header;
+	image_desc_t *desc;
+	unsigned long align = 1;
+	int fflag = 0;
+
+	if (argc < 2)
+		remove_usage();
+
+	opts = fill_common_opts(opts, &nr_opts, no_argument);
+	opts = add_opt(opts, &nr_opts, "align", required_argument, OPT_ALIGN);
+	opts = add_opt(opts, &nr_opts, "blob", required_argument, 'b');
+	opts = add_opt(opts, &nr_opts, "force", no_argument, 'f');
+	opts = add_opt(opts, &nr_opts, "out", required_argument, 'o');
+	opts = add_opt(opts, &nr_opts, NULL, 0, 0);
+
+	while (1) {
+		int c, opt_index = 0;
+
+		c = getopt_long(argc, argv, "b:fo:", opts, &opt_index);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case OPT_TOC_ENTRY: {
+			image_desc_t *desc;
+
+			desc = lookup_image_desc_from_opt(opts[opt_index].name);
+			set_image_desc_action(desc, DO_REMOVE, NULL);
+			break;
+		}
+		case OPT_ALIGN:
+			align = get_image_align(optarg);
+			break;
+		case 'b': {
+			char name[_UUID_STR_LEN + 1], filename[PATH_MAX];
+			uuid_t uuid = uuid_null;
+			uint64_t nvm_offset = 0xFFFFFFFF;
+			image_desc_t *desc;
+
+			parse_blob_opt(optarg, &uuid,
+			    filename, sizeof(filename), &nvm_offset);
+
+			if (memcmp(&uuid, &uuid_null, sizeof(uuid_t)) == 0)
+				remove_usage();
+
+			desc = lookup_image_desc_from_uuid(&uuid);
+			if (desc == NULL) {
+				uuid_to_str(name, sizeof(name), &uuid);
+				desc = new_image_desc(&uuid, name, "blob", nvm_offset);
+				add_image_desc(desc);
+			}
+			set_image_desc_action(desc, DO_REMOVE, NULL);
+			break;
+		}
+		case 'f':
+			fflag = 1;
+			break;
+		case 'o':
+			snprintf(outfile, sizeof(outfile), "%s", optarg);
+			break;
+		default:
+			remove_usage();
+		}
+	}
+	argc -= optind;
+	argv += optind;
+	free(opts);
+
+	if (argc == 0)
+		remove_usage();
+
+	if (outfile[0] != '\0' && access(outfile, F_OK) == 0 && !fflag)
+		log_errx("File %s already exists, use --force to overwrite it",
+		    outfile);
+
+	if (outfile[0] == '\0')
+		snprintf(outfile, sizeof(outfile), "%s", argv[0]);
+
+	parse_fip(argv[0], &toc_header);
+
+	for (desc = image_desc_head; desc != NULL; desc = desc->next) {
+		if (desc->action != DO_REMOVE)
+			continue;
+
+		if (desc->image != NULL) {
+			if (verbose)
+				log_dbgx("Removing %s",
+				    desc->cmdline_name);
+			free(desc->image);
+			desc->image = NULL;
+		} else {
+			log_warnx("%s does not exist in %s",
+			    desc->cmdline_name, argv[0]);
+		}
+	}
+
+	pack_images(outfile, toc_header.flags, align);
+	return 0;
+}
+
+static void remove_usage(void)
+{
+	toc_entry_t *toc_entry = toc_entries;
+
+	printf("fiptool remove [opts] FIP_FILENAME\n");
+	printf("\n");
+	printf("Options:\n");
+	printf("  --align <value>\tEach image is aligned to <value> (default: 1).\n");
+	printf("  --blob uuid=...\tRemove an image with the given UUID.\n");
+	printf("  --force\t\tIf the output FIP file already exists, use --force to overwrite it.\n");
+	printf("  --out FIP_FILENAME\tSet an alternative output FIP file.\n");
+	printf("\n");
+	printf("Specific images are removed with the following options:\n");
+	for (; toc_entry->cmdline_name != NULL; toc_entry++)
+		printf("  --%-16s\t%s\n", toc_entry->cmdline_name,
+		    toc_entry->name);
+	exit(1);
+}
+
+static int version_cmd(int argc, char *argv[])
+{
+#ifdef VERSION
+	puts(VERSION);
+#else
+	/* If built from fiptool directory, VERSION is not set. */
+	puts("Unknown version");
+#endif
+	return 0;
+}
+
+static void version_usage(void)
+{
+	printf("fiptool version\n");
+	exit(1);
+}
+
+static int help_cmd(int argc, char *argv[])
+{
+	int i;
+
+	if (argc < 2)
+		usage();
+	argc--, argv++;
+
+	for (i = 0; i < NELEM(cmds); i++) {
+		if (strcmp(cmds[i].name, argv[0]) == 0 &&
+		    cmds[i].usage != NULL)
+			cmds[i].usage();
+	}
+	if (i == NELEM(cmds))
+		printf("No help for subcommand '%s'\n", argv[0]);
+	return 0;
+}
+
+static void usage(void)
+{
+	printf("usage: fiptool [--verbose] <command> [<args>]\n");
+	printf("Global options supported:\n");
+	printf("  --verbose\tEnable verbose output for all commands.\n");
+	printf("\n");
+	printf("Commands supported:\n");
+	printf("  info\t\tList images contained in FIP.\n");
+	printf("  create\tCreate a new FIP with the given images.\n");
+	printf("  update\tUpdate an existing FIP with the given images.\n");
+	printf("  unpack\tUnpack images from FIP.\n");
+	printf("  remove\tRemove images from FIP.\n");
+	printf("  version\tShow fiptool version.\n");
+	printf("  help\t\tShow help for given command.\n");
+	exit(1);
+}
+
+int main(int argc, char *argv[])
+{
+	int i, ret = 0;
+
+	while (1) {
+		int c, opt_index = 0;
+		static struct option opts[] = {
+			{ "verbose", no_argument, NULL, 'v' },
+			{ NULL, no_argument, NULL, 0 }
+		};
+
+		/*
+		 * Set POSIX mode so getopt stops at the first non-option
+		 * which is the subcommand.
+		 */
+		c = getopt_long(argc, argv, "+v", opts, &opt_index);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case 'v':
+			verbose = 1;
+			break;
+		default:
+			usage();
+		}
+	}
+	argc -= optind;
+	argv += optind;
+	/* Reset optind for subsequent getopt processing. */
+	optind = 0;
+
+	if (argc == 0)
+		usage();
+
+	fill_image_descs();
+	for (i = 0; i < NELEM(cmds); i++) {
+		if (strcmp(cmds[i].name, argv[0]) == 0) {
+			ret = cmds[i].handler(argc, argv);
+			break;
+		}
+	}
+	if (i == NELEM(cmds))
+		usage();
+	free_image_descs();
+	return ret;
+}
diff --git a/tools/renesas/rzg_security_tools/fiptool/src/fiptool.h b/tools/renesas/rzg_security_tools/fiptool/src/fiptool.h
new file mode 100644
index 0000000..c97dfbd
--- /dev/null
+++ b/tools/renesas/rzg_security_tools/fiptool/src/fiptool.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2016-2017, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2021, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef FIPTOOL_H
+#define FIPTOOL_H
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <rzg_firmware_image_package.h>
+#include <uuid.h>
+
+#include "fiptool_platform.h"
+
+#define NELEM(x) (sizeof (x) / sizeof *(x))
+
+enum {
+	DO_UNSPEC = 0,
+	DO_PACK   = 1,
+	DO_UNPACK = 2,
+	DO_REMOVE = 3
+};
+
+enum {
+	LOG_DBG,
+	LOG_WARN,
+	LOG_ERR
+};
+
+typedef struct image_desc {
+	uuid_t             uuid;
+	char              *name;
+	char              *cmdline_name;
+	int                action;
+	char              *action_arg;
+	uint64_t           nvm_offset;
+	struct image      *image;
+	struct image_desc *next;
+} image_desc_t;
+
+typedef struct image {
+	struct fip_toc_entry toc_e;
+	void                *buffer;
+} image_t;
+
+typedef struct cmd {
+	char              *name;
+	int              (*handler)(int, char **);
+	void             (*usage)(void);
+} cmd_t;
+
+#endif /* FIPTOOL_H */
diff --git a/tools/renesas/rzg_security_tools/fiptool/src/fiptool_platform.h b/tools/renesas/rzg_security_tools/fiptool/src/fiptool_platform.h
new file mode 100644
index 0000000..9bfa298
--- /dev/null
+++ b/tools/renesas/rzg_security_tools/fiptool/src/fiptool_platform.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2016-2018, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+/*
+ * Build platform specific handling.
+ * This allows for builds on non-Posix platforms
+ * e.g. Visual Studio on Windows
+ */
+
+#ifndef FIPTOOL_PLATFORM_H
+#define FIPTOOL_PLATFORM_H
+
+#ifndef _MSC_VER
+
+/* Not Visual Studio, so include Posix Headers. */
+# include <getopt.h>
+# include <openssl/sha.h>
+# include <unistd.h>
+
+# define  BLD_PLAT_STAT stat
+
+#else
+
+/* Visual Studio. */
+# include "win_posix.h"
+
+#endif
+
+#endif /* FIPTOOL_PLATFORM_H */
diff --git a/tools/renesas/rzg_security_tools/fiptool/src/rzg_firmware_image_package.h b/tools/renesas/rzg_security_tools/fiptool/src/rzg_firmware_image_package.h
new file mode 100644
index 0000000..c520c7d
--- /dev/null
+++ b/tools/renesas/rzg_security_tools/fiptool/src/rzg_firmware_image_package.h
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2014-2018, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2021, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef RZG_FIRMWARE_IMAGE_PACKAGE_H
+#define RZG_FIRMWARE_IMAGE_PACKAGE_H
+
+#include <stdint.h>
+
+#include "uuid.h"
+
+/* This is used as a signature to validate the blob header */
+#if defined(_PKG_FW_IPL)
+	#define TOC_HEADER_NAME	0xAA640001
+#elif defined(_PKG_KEYRING)
+	#define TOC_HEADER_NAME	0xAA640002
+#elif defined(_PKG_BOOT_FW)
+	#define TOC_HEADER_NAME	0xAA640003
+#else
+	#error "The package definition cannot be found."
+#endif
+
+
+/* ToC Entry UUIDs */
+#define UUID_TRUSTED_UPDATE_FIRMWARE_NS_BL2U \
+	{{0x4f, 0x51, 0x1d, 0x11}, {0x2b, 0xe5}, {0x4e, 0x49}, 0xb4, 0xc5, {0x83, 0xc2, 0xf7, 0x15, 0x84, 0x0a} }
+#define UUID_TRUSTED_BOOT_FIRMWARE_BL2 \
+	{{0x5f, 0xf9, 0xec, 0x0b}, {0x4d, 0x22}, {0x3e, 0x4d}, 0xa5, 0x44, {0xc3, 0x9d, 0x81, 0xc7, 0x3f, 0x0a} }
+#define UUID_EL3_RUNTIME_FIRMWARE_BL31 \
+	{{0x47, 0xd4, 0x08, 0x6d}, {0x4c, 0xfe}, {0x98, 0x46}, 0x9b, 0x95, {0x29, 0x50, 0xcb, 0xbd, 0x5a, 0x00} }
+#define UUID_SECURE_PAYLOAD_BL32 \
+	{{0x05, 0xd0, 0xe1, 0x89}, {0x53, 0xdc}, {0x13, 0x47}, 0x8d, 0x2b, {0x50, 0x0a, 0x4b, 0x7a, 0x3e, 0x38} }
+#define UUID_SECURE_PAYLOAD_BL32_EXTRA2 \
+	{{0xa7, 0x4d, 0x09, 0x44}, {0x4f, 0x2c}, {0x11, 0xeb}, 0xa7, 0x2d, {0xf3, 0x35, 0x07, 0xaf, 0x39, 0x9a} }
+#define UUID_SECURE_PAYLOAD_BL32_EXTRA3 \
+	{{0xab, 0x46, 0x5c, 0x30}, {0x4f, 0x2c}, {0x11, 0xeb}, 0xa1, 0x7c, {0xbf, 0x2d, 0x2a, 0x50, 0x23, 0x77} }
+#define UUID_SECURE_PAYLOAD_BL32_EXTRA4 \
+	{{0xab, 0xb9, 0xd4, 0xda}, {0x4f, 0x2c}, {0x11, 0xeb}, 0xbd, 0xf3, {0xb3, 0x59, 0x22, 0x6b, 0xdc, 0x5a} }
+#define UUID_SECURE_PAYLOAD_BL32_EXTRA5 \
+	{{0xac, 0x02, 0x29, 0x9c}, {0x4f, 0x2c}, {0x11, 0xeb}, 0x9d, 0x8c, {0x0f, 0xc9, 0xeb, 0x8a, 0x1f, 0xd2} }
+#define UUID_NON_TRUSTED_FIRMWARE_BL33 \
+	{{0xd6, 0xd0, 0xee, 0xa7}, {0xfc, 0xea}, {0xd5, 0x4b}, 0x97, 0x82, {0x99, 0x34, 0xf2, 0x34, 0xb6, 0xe4} }
+#define UUID_SECURE_PAYLOAD_BL32_EXTRA1 \
+	{{0xa4, 0x9c, 0xa1, 0xd2}, {0x4f, 0x2c}, {0x11, 0xeb}, 0xa3, 0xe0, {0xe7, 0xd3, 0xf6, 0x51, 0x61, 0x52} }
+#define UUID_NON_TRUSTED_FIRMWARE_BL33_EXTRA1 \
+	{{0xd6, 0x46, 0xf9, 0xfc}, {0x4f, 0x2d}, {0x11, 0xeb}, 0xbd, 0x4c, {0x6f, 0xeb, 0x6b, 0x96, 0x6b, 0xca} }
+#define UUID_NON_TRUSTED_FIRMWARE_BL33_EXTRA2 \
+	{{0xd6, 0xce, 0x07, 0xc6}, {0x4f, 0x2d}, {0x11, 0xeb}, 0x9f, 0xf1, {0x4b, 0xfa, 0x50, 0xb4, 0x03, 0x41} }
+#define UUID_NON_TRUSTED_FIRMWARE_BL33_EXTRA3 \
+	{{0xd7, 0x24, 0xfb, 0xe4}, {0x4f, 0x2d}, {0x11, 0xeb}, 0xb8, 0x15, {0xcb, 0x5e, 0xbe, 0x25, 0xc2, 0xc4} }
+#define UUID_NON_TRUSTED_FIRMWARE_BL33_EXTRA4 \
+	{{0xd7, 0x90, 0x17, 0x76}, {0x4f, 0x2d}, {0x11, 0xeb}, 0xb3, 0x0c, {0xdf, 0x43, 0x89, 0x23, 0x0d, 0x61} }
+#define UUID_NON_TRUSTED_FIRMWARE_BL33_EXTRA5 \
+	{{0xd7, 0xe7, 0x20, 0x66}, {0x4f, 0x2d}, {0x11, 0xeb}, 0x98, 0x54, {0x8f, 0x01, 0x5f, 0x81, 0xe9, 0x7c} }
+#define UUID_NON_TRUSTED_FIRMWARE_BL33_EXTRA6 \
+	{{0xd8, 0x38, 0xfd, 0xaa}, {0x4f, 0x2d}, {0x11, 0xeb}, 0xaa, 0x5b, {0x93, 0x2a, 0x77, 0xf6, 0x9f, 0x4c} }
+#define UUID_NON_TRUSTED_FIRMWARE_BL33_EXTRA7 \
+	{{0xd8, 0x98, 0x76, 0x0e}, {0x4f, 0x2d}, {0x11, 0xeb}, 0xa5, 0x41, {0xc7, 0x2b, 0xf3, 0x39, 0xd6, 0x50} }
+#define UUID_NON_TRUSTED_FIRMWARE_BL33_EXTRA8 \
+	{{0xd9, 0x02, 0xbd, 0xd4}, {0x4f, 0x2d}, {0x11, 0xeb}, 0xb1, 0x67, {0xa3, 0x67, 0x20, 0xf6, 0xeb, 0x3a} }
+/* Content certificates */
+#define UUID_TRUSTED_BOOT_FW_CERT \
+	{{0xd6, 0xe2, 0x69, 0xea}, {0x5d, 0x63}, {0xe4, 0x11}, 0x8d, 0x8c, {0x9f, 0xba, 0xbe, 0x99, 0x56, 0xa5} }
+#define UUID_SOC_FW_CONTENT_CERT \
+	{{0xe2, 0xb2, 0x0c, 0x20}, {0x5e, 0x63}, {0xe4, 0x11}, 0x9c, 0xe8, {0xab, 0xcc, 0xf9, 0x2b, 0xb6, 0x66} }
+/* Trusted Boot Keyring */
+#define UUID_TRUSTED_BOOT_KEYRING \
+	{{0xcf, 0x6d, 0xf0, 0xf3}, {0x8f, 0x9e}, {0x43, 0x04}, 0x9e, 0xbd, {0xe1, 0x63, 0x15, 0x69, 0xa4, 0xbb} }
+/* Security Module */
+#define UUID_TRUSTED_BOOT_SEC_MODULE \
+	{{0x86, 0x7e, 0xcf, 0xd1}, {0xd8, 0x26}, {0x42, 0x93}, 0xb2, 0xe3, {0x9a, 0x1a, 0x5a, 0x77, 0x4c, 0x11} }
+
+typedef struct fip_toc_header {
+	uint32_t	name;
+	uint32_t	serial_number;
+	uint64_t	flags;
+} fip_toc_header_t;
+
+typedef struct fip_toc_entry {
+	uuid_t		uuid;
+	uint64_t	offset_address;
+	uint64_t	size;
+	uint64_t	flags;
+	uint64_t	nvm_offset;
+} fip_toc_entry_t;
+
+#endif /* RZG_FIRMWARE_IMAGE_PACKAGE_H */
+
diff --git a/tools/renesas/rzg_security_tools/fiptool/src/tbbr_config.c b/tools/renesas/rzg_security_tools/fiptool/src/tbbr_config.c
new file mode 100644
index 0000000..2f8159e
--- /dev/null
+++ b/tools/renesas/rzg_security_tools/fiptool/src/tbbr_config.c
@@ -0,0 +1,154 @@
+/*
+ * Copyright (c) 2016-2018, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2021, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stddef.h>
+
+#include <rzg_firmware_image_package.h>
+
+#include "tbbr_config.h"
+
+/* The images used depends on the platform. */
+toc_entry_t toc_entries[] = {
+#if defined(_PKG_FW_IPL)
+	{
+		.name = "Trusted Boot Firmware BL2 certificate",
+		.uuid = UUID_TRUSTED_BOOT_FW_CERT,
+		.cmdline_name = "tb-fw-cert",
+		.nvm_offset = 0x00000000
+	},
+	{
+		.name = "Trusted Boot Firmware BL2",
+		.uuid = UUID_TRUSTED_BOOT_FIRMWARE_BL2,
+		.cmdline_name = "tb-fw",
+		.nvm_offset = 0x00040000
+	},
+	{
+		.name = "SoC Firmware content certificate",
+		.uuid = UUID_SOC_FW_CONTENT_CERT,
+		.cmdline_name = "soc-fw-cert",
+		.nvm_offset = 0x00180000
+	},
+	{
+		.name = "Trusted Boot Firmware Security Module",
+		.uuid = UUID_TRUSTED_BOOT_SEC_MODULE,
+		.cmdline_name = "sec-mod",
+		.nvm_offset = 0x00400000U
+	},
+#elif defined(_PKG_KEYRING)
+	{
+		.name = "Trusted Boot Keyring",
+		.uuid = UUID_TRUSTED_BOOT_KEYRING,
+		.cmdline_name = "key-ring",
+		.nvm_offset = 0x00500000U
+	},
+#elif defined(_PKG_BOOT_FW)
+	{
+		.name = "EL3 Runtime Firmware BL31",
+		.uuid = UUID_EL3_RUNTIME_FIRMWARE_BL31,
+		.cmdline_name = "soc-fw",
+		.nvm_offset = 0x001C0000U
+	},
+	{
+		.name = "Secure Payload BL32 (Trusted OS)",
+		.uuid = UUID_SECURE_PAYLOAD_BL32,
+		.cmdline_name = "tos-fw",
+		.nvm_offset = 0x00200000U
+	},
+	{
+		.name = "Non-Trusted Firmware BL33",
+		.uuid = UUID_NON_TRUSTED_FIRMWARE_BL33,
+		.cmdline_name = "nt-fw",
+		.nvm_offset = 0x00300000U
+	},
+	{
+		.name = "Secure Payload BL32 Extra1 (Trusted OS Extra1)",
+		.uuid = UUID_SECURE_PAYLOAD_BL32_EXTRA1,
+		.cmdline_name = "tos-fw-extra1",
+		.nvm_offset = 0xFFFFFFFFU
+	},
+	{
+		.name = "Secure Payload BL32 Extra2 (Trusted OS Extra2)",
+		.uuid = UUID_SECURE_PAYLOAD_BL32_EXTRA2,
+		.cmdline_name = "tos-fw-extra2",
+		.nvm_offset = 0xFFFFFFFFU
+	},
+	{
+		.name = "Secure Payload BL32 Extra3 (Trusted OS Extra3)",
+		.uuid = UUID_SECURE_PAYLOAD_BL32_EXTRA3,
+		.cmdline_name = "tos-fw-extra3",
+		.nvm_offset = 0xFFFFFFFFU
+	},
+	{
+		.name = "Secure Payload BL32 Extra4 (Trusted OS Extra4)",
+		.uuid = UUID_SECURE_PAYLOAD_BL32_EXTRA4,
+		.cmdline_name = "tos-fw-extra4",
+		.nvm_offset = 0xFFFFFFFFU
+	},
+	{
+		.name = "Secure Payload BL32 Extra5 (Trusted OS Extra5)",
+		.uuid = UUID_SECURE_PAYLOAD_BL32_EXTRA5,
+		.cmdline_name = "tos-fw-extra5",
+		.nvm_offset = 0xFFFFFFFFU
+	},
+	{
+		.name = "Non-Trusted Firmware BL33 Extra1",
+		.uuid = UUID_NON_TRUSTED_FIRMWARE_BL33_EXTRA1,
+		.cmdline_name = "nt-fw-extra1",
+		.nvm_offset = 0xFFFFFFFFU
+	},
+	{
+		.name = "Non-Trusted Firmware BL33 Extra2",
+		.uuid = UUID_NON_TRUSTED_FIRMWARE_BL33_EXTRA2,
+		.cmdline_name = "nt-fw-extra2",
+		.nvm_offset = 0xFFFFFFFFU
+	},
+	{
+		.name = "Non-Trusted Firmware BL33 Extra3",
+		.uuid = UUID_NON_TRUSTED_FIRMWARE_BL33_EXTRA3,
+		.cmdline_name = "nt-fw-extra3",
+		.nvm_offset = 0xFFFFFFFFU
+	},
+	{
+		.name = "Non-Trusted Firmware BL33 Extra4",
+		.uuid = UUID_NON_TRUSTED_FIRMWARE_BL33_EXTRA4,
+		.cmdline_name = "nt-fw-extra4",
+		.nvm_offset = 0xFFFFFFFFU
+	},
+	{
+		.name = "Non-Trusted Firmware BL33 Extra5",
+		.uuid = UUID_NON_TRUSTED_FIRMWARE_BL33_EXTRA5,
+		.cmdline_name = "nt-fw-extra5",
+		.nvm_offset = 0xFFFFFFFFU
+	},
+	{
+		.name = "Non-Trusted Firmware BL33 Extra6",
+		.uuid = UUID_NON_TRUSTED_FIRMWARE_BL33_EXTRA6,
+		.cmdline_name = "nt-fw-extra6",
+		.nvm_offset = 0xFFFFFFFFU
+	},
+	{
+		.name = "Non-Trusted Firmware BL33 Extra7",
+		.uuid = UUID_NON_TRUSTED_FIRMWARE_BL33_EXTRA7,
+		.cmdline_name = "nt-fw-extra7",
+		.nvm_offset = 0xFFFFFFFFU
+	},
+	{
+		.name = "Non-Trusted Firmware BL33 Extra8",
+		.uuid = UUID_NON_TRUSTED_FIRMWARE_BL33_EXTRA8,
+		.cmdline_name = "nt-fw-extra8",
+		.nvm_offset = 0xFFFFFFFFU
+	},
+#else
+	#error "The package definition cannot be found."
+#endif
+	{
+		.name = NULL,
+		.uuid = { {0} },
+		.cmdline_name = NULL,
+		.nvm_offset = 0xFFFFFFFFU
+	}
+};
diff --git a/tools/renesas/rzg_security_tools/fiptool/src/tbbr_config.h b/tools/renesas/rzg_security_tools/fiptool/src/tbbr_config.h
new file mode 100644
index 0000000..4efd8be
--- /dev/null
+++ b/tools/renesas/rzg_security_tools/fiptool/src/tbbr_config.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2016-2017, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2021, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef TBBR_CONFIG_H
+#define TBBR_CONFIG_H
+
+#include <stdint.h>
+
+#include <uuid.h>
+
+#define TOC_HEADER_SERIAL_NUMBER 0x12345678
+
+typedef struct toc_entry {
+	char         *name;
+	uuid_t        uuid;
+	char         *cmdline_name;
+	uint64_t      nvm_offset;
+} toc_entry_t;
+
+extern toc_entry_t toc_entries[];
+
+#endif /* TBBR_CONFIG_H */
diff --git a/tools/renesas/rzg_security_tools/sign_fw/Makefile b/tools/renesas/rzg_security_tools/sign_fw/Makefile
new file mode 100644
index 0000000..027b090
--- /dev/null
+++ b/tools/renesas/rzg_security_tools/sign_fw/Makefile
@@ -0,0 +1,66 @@
+#
+# Copyright (c) 2019, Linaro Limited. All rights reserved.
+# Copyright (c) 2021, Renesas Electronics Corporation. All rights reserved.
+#
+# SPDX-License-Identifier: BSD-3-Clause
+#
+
+PROJECT		:= sign_fw
+V		?= 0
+BUILD_INFO	?= 1
+DEBUG		:= 0
+BINARY		:= ${PROJECT}${BIN_EXT}
+OPENSSL_DIR	:= /usr
+
+OBJECTS := src/sign.o \
+           src/cmd_opt.o \
+           src/main.o
+
+HOSTCCFLAGS := -Wall -std=c99
+
+MAKE_HELPERS_DIRECTORY := ../../../../make_helpers/
+include ${MAKE_HELPERS_DIRECTORY}build_macros.mk
+include ${MAKE_HELPERS_DIRECTORY}build_env.mk
+
+ifeq (${DEBUG},1)
+  HOSTCCFLAGS += -g -O0 -DDEBUG -DLOG_LEVEL=40
+else
+ifeq (${BUILD_INFO},1)
+  HOSTCCFLAGS += -O2 -DLOG_LEVEL=20
+else
+  HOSTCCFLAGS += -O2 -DLOG_LEVEL=10
+endif
+endif
+ifeq (${V},0)
+  Q := @
+else
+  Q :=
+endif
+
+# Make soft links and include from local directory otherwise wrong headers
+# could get pulled in from firmware tree.
+INC_DIR := -I ./include -I ../../../../include/tools_share -I ${OPENSSL_DIR}/include
+LIB_DIR := -L ${OPENSSL_DIR}/lib
+LIB := -lssl -lcrypto
+
+HOSTCC ?= gcc
+
+.PHONY: all clean realclean
+
+all: clean ${BINARY}
+
+${BINARY}: ${OBJECTS} Makefile
+	@echo "  HOSTLD  $@"
+	@echo 'const char build_msg[] = "Built : "__TIME__", "__DATE__;' | \
+                ${HOSTCC} -c ${HOSTCCFLAGS} -xc - -o src/build_msg.o
+	${Q}${HOSTCC} src/build_msg.o ${OBJECTS} ${LIB_DIR} ${LIB} -o $@
+
+%.o: %.c
+	@echo "  HOSTCC  $<"
+	${Q}${HOSTCC} -c ${HOSTCCFLAGS} ${INC_DIR} $< -o $@
+
+clean:
+	$(call SHELL_DELETE_ALL, src/build_msg.o ${OBJECTS})
+
+realclean: clean
+	$(call SHELL_DELETE,${BINARY})
diff --git a/tools/renesas/rzg_security_tools/sign_fw/include/cmd_opt.h b/tools/renesas/rzg_security_tools/sign_fw/include/cmd_opt.h
new file mode 100644
index 0000000..bd7d31f
--- /dev/null
+++ b/tools/renesas/rzg_security_tools/sign_fw/include/cmd_opt.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2015, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2019, Linaro Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef CMD_OPT_H
+#define CMD_OPT_H
+
+#include <getopt.h>
+
+#define CMD_OPT_MAX_NUM			64
+
+/* Supported long command line option types */
+enum {
+	CMD_OPT_FW
+};
+
+/* Structure to define a command line option */
+typedef struct cmd_opt_s {
+	struct option long_opt;
+	const char *help_msg;
+} cmd_opt_t;
+
+/* Exported API*/
+void cmd_opt_add(const cmd_opt_t *cmd_opt);
+const struct option *cmd_opt_get_array(void);
+const char *cmd_opt_get_name(int idx);
+const char *cmd_opt_get_help_msg(int idx);
+
+#endif /* CMD_OPT_H */
diff --git a/tools/renesas/rzg_security_tools/sign_fw/include/debug.h b/tools/renesas/rzg_security_tools/sign_fw/include/debug.h
new file mode 100644
index 0000000..ee8f1f5
--- /dev/null
+++ b/tools/renesas/rzg_security_tools/sign_fw/include/debug.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2015, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef DEBUG_H
+#define DEBUG_H
+
+#include <stdio.h>
+
+/* The log output macros print output to the console. These macros produce
+ * compiled log output only if the LOG_LEVEL defined in the makefile (or the
+ * make command line) is greater or equal than the level required for that
+ * type of log output.
+ * The format expected is the same as for printf(). For example:
+ * INFO("Info %s.\n", "message")    -> INFO:    Info message.
+ * WARN("Warning %s.\n", "message") -> WARNING: Warning message.
+ */
+
+#define LOG_LEVEL_NONE			0
+#define LOG_LEVEL_ERROR			10
+#define LOG_LEVEL_NOTICE		20
+#define LOG_LEVEL_WARNING		30
+#define LOG_LEVEL_INFO			40
+#define LOG_LEVEL_VERBOSE		50
+
+
+#if LOG_LEVEL >= LOG_LEVEL_NOTICE
+# define NOTICE(...)	printf("NOTICE:  " __VA_ARGS__)
+#else
+# define NOTICE(...)
+#endif
+
+#if LOG_LEVEL >= LOG_LEVEL_ERROR
+# define ERROR(...)	printf("ERROR:   " __VA_ARGS__)
+#else
+# define ERROR(...)
+#endif
+
+#if LOG_LEVEL >= LOG_LEVEL_WARNING
+# define WARN(...)	printf("WARNING: " __VA_ARGS__)
+#else
+# define WARN(...)
+#endif
+
+#if LOG_LEVEL >= LOG_LEVEL_INFO
+# define INFO(...)	printf("INFO:    " __VA_ARGS__)
+#else
+# define INFO(...)
+#endif
+
+#if LOG_LEVEL >= LOG_LEVEL_VERBOSE
+# define VERBOSE(...)	printf("VERBOSE: " __VA_ARGS__)
+#else
+# define VERBOSE(...)
+#endif
+
+#endif /* DEBUG_H */
diff --git a/tools/renesas/rzg_security_tools/sign_fw/include/sign.h b/tools/renesas/rzg_security_tools/sign_fw/include/sign.h
new file mode 100644
index 0000000..8a2b3e8
--- /dev/null
+++ b/tools/renesas/rzg_security_tools/sign_fw/include/sign.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2021, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef SIGN_H
+#define SIGN_H
+
+/* Supported key algorithms */
+enum {
+	KEY_ALG_RSA,		/* RSASSA-PKCS1-v1_5 (default) */
+	KEY_ALG_MAX_NUM
+};
+
+/* Supported hash algorithms */
+enum{
+	HASH_ALG_SHA256,
+};
+
+int sign_file(int key_alg, char *key_name, int md_alg, 
+		const char *ip_name, const char *op_name, unsigned int align);
+
+#endif /* SIGN_H */
diff --git a/tools/renesas/rzg_security_tools/sign_fw/src/cmd_opt.c b/tools/renesas/rzg_security_tools/sign_fw/src/cmd_opt.c
new file mode 100644
index 0000000..64180d1
--- /dev/null
+++ b/tools/renesas/rzg_security_tools/sign_fw/src/cmd_opt.c
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2015, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <cmd_opt.h>
+#include <getopt.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include "debug.h"
+
+/* Command line options */
+static struct option long_opt[CMD_OPT_MAX_NUM+1];
+static const char *help_msg[CMD_OPT_MAX_NUM+1];
+static int num_reg_opt;
+
+void cmd_opt_add(const cmd_opt_t *cmd_opt)
+{
+	assert(cmd_opt != NULL);
+
+	if (num_reg_opt >= CMD_OPT_MAX_NUM) {
+		ERROR("Out of memory. Please increase CMD_OPT_MAX_NUM\n");
+		exit(1);
+	}
+
+	long_opt[num_reg_opt].name = cmd_opt->long_opt.name;
+	long_opt[num_reg_opt].has_arg = cmd_opt->long_opt.has_arg;
+	long_opt[num_reg_opt].flag = 0;
+	long_opt[num_reg_opt].val = cmd_opt->long_opt.val;
+
+	help_msg[num_reg_opt] = cmd_opt->help_msg;
+
+	num_reg_opt++;
+}
+
+const struct option *cmd_opt_get_array(void)
+{
+	return long_opt;
+}
+
+const char *cmd_opt_get_name(int idx)
+{
+	if (idx >= num_reg_opt) {
+		return NULL;
+	}
+
+	return long_opt[idx].name;
+}
+
+const char *cmd_opt_get_help_msg(int idx)
+{
+	if (idx >= num_reg_opt) {
+		return NULL;
+	}
+
+	return help_msg[idx];
+}
diff --git a/tools/renesas/rzg_security_tools/sign_fw/src/main.c b/tools/renesas/rzg_security_tools/sign_fw/src/main.c
new file mode 100644
index 0000000..4d71d80
--- /dev/null
+++ b/tools/renesas/rzg_security_tools/sign_fw/src/main.c
@@ -0,0 +1,253 @@
+/*
+ * Copyright (c) 2019, Linaro Limited. All rights reserved.
+ * Author: Sumit Garg <sumit.garg@linaro.org>
+ *
+ * Copyright (c) 2021, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <limits.h>
+#include <ctype.h>
+#include <getopt.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+
+#include <openssl/conf.h>
+
+#include "cmd_opt.h"
+#include "debug.h"
+#include "sign.h"
+#include "firmware_encrypted.h"
+
+#define NUM_ELEM(x)			((sizeof(x)) / (sizeof(x[0])))
+#define HELP_OPT_MAX_LEN		128
+
+/* Global options */
+
+/* Info messages created in the Makefile */
+extern const char build_msg[];
+
+static char *key_algs_str[] = {
+	[KEY_ALG_RSA] = "rsa",
+};
+
+static const char *hash_algs_str[] = {
+	[HASH_ALG_SHA256] = "sha256",
+};
+
+
+static void print_help(const char *cmd, const struct option *long_opt)
+{
+	int rem, i = 0;
+	const struct option *opt;
+	char line[HELP_OPT_MAX_LEN];
+	char *p;
+
+	assert(cmd != NULL);
+	assert(long_opt != NULL);
+
+	printf("\n\n");
+	printf("The firmware encryption tool loads the binary image and\n"
+	       "outputs encrypted binary image using an encryption key\n"
+	       "provided as an input hex string.\n");
+	printf("\n");
+	printf("Usage:\n");
+	printf("\t%s [OPTIONS]\n\n", cmd);
+
+	printf("Available options:\n");
+	opt = long_opt;
+	while (opt->name) {
+		p = line;
+		rem = HELP_OPT_MAX_LEN;
+		if (isalpha(opt->val)) {
+			/* Short format */
+			sprintf(p, "-%c,", (char)opt->val);
+			p += 3;
+			rem -= 3;
+		}
+		snprintf(p, rem, "--%s %s", opt->name,
+			 (opt->has_arg == required_argument) ? "<arg>" : "");
+		printf("\t%-32s %s\n", line, cmd_opt_get_help_msg(i));
+		opt++;
+		i++;
+	}
+	printf("\n");
+}
+
+static int get_key_alg(const char *key_alg_str)
+{
+	int i;
+
+	for (i = 0 ; i < NUM_ELEM(key_algs_str) ; i++) {
+		if (strcmp(key_alg_str, key_algs_str[i]) == 0) {
+			return i;
+		}
+	}
+
+	return -1;
+}
+
+static int get_hash_alg(const char *hash_alg_str)
+{
+	int i;
+
+	for (i = 0 ; i < NUM_ELEM(hash_algs_str) ; i++) {
+		if (0 == strcmp(hash_alg_str, hash_algs_str[i])) {
+			return i;
+		}
+	}
+
+	return -1;
+}
+
+static int is_power_of_2(unsigned long x)
+{
+	return x && !(x & (x - 1));
+}
+
+static int get_image_align(char *arg)
+{
+	char *endptr;
+	unsigned long align;
+
+	errno = 0;
+	align = strtoul(arg, &endptr, 0);
+	if (*endptr != '\0' || !is_power_of_2(align) || INT_MAX < align || errno != 0) {
+		return -1;
+	}
+
+	return align;
+}
+
+/* Common command line options */
+static const cmd_opt_t common_cmd_opt[] = {
+	{
+		{ "help", no_argument, NULL, 'h' },
+		"Print this message and exit"
+	},
+	{
+		{ "key-alg", required_argument, NULL, 'a' },
+		"Key algorithm: 'rsa' (default)- RSASSA-PKCS1-v1_5"
+	},
+	{
+		{ "key", required_argument, NULL, 'k' },
+		"Signing key filename(for supported algorithm)."
+	},
+	{
+		{ "hash-alg", required_argument, NULL, 's' },
+		"Hash algorithm : 'sha256' (default)"
+	},
+	{
+		{ "in", required_argument, NULL, 'i' },
+		"Input filename to be signed."
+	},
+	{
+		{ "out", required_argument, NULL, 'o' },
+		"Signed output filename."
+	},
+	{
+		{ "align", required_argument, NULL, 'n' },
+		"Input file is aligned to <arg> (default: 16)."
+	},
+};
+
+int main(int argc, char *argv[])
+{
+	int i, key_alg, md_alg, align, ret;
+	int c, opt_idx = 0;
+	const struct option *cmd_opt;
+	char *key_fn = NULL;
+	char *in_fn = NULL;
+	char *out_fn = NULL;
+
+	NOTICE("Firmware Signing Tool: %s\n", build_msg);
+
+	/* Set default options */
+	key_alg = KEY_ALG_RSA;
+	md_alg = HASH_ALG_SHA256;
+	align = 16;
+
+	/* Add common command line options */
+	for (i = 0; i < NUM_ELEM(common_cmd_opt); i++) {
+		cmd_opt_add(&common_cmd_opt[i]);
+	}
+
+	/* Get the command line options populated during the initialization */
+	cmd_opt = cmd_opt_get_array();
+
+	while (1) {
+		/* getopt_long stores the option index here. */
+		c = getopt_long(argc, argv, "a:f:hi:k:n:o:", cmd_opt, &opt_idx);
+
+		/* Detect the end of the options. */
+		if (c == -1) {
+			break;
+		}
+
+		switch (c) {
+		case 'a':
+			key_alg = get_key_alg(optarg);
+			if (key_alg < 0) {
+				ERROR("Invalid key algorithm '%s'\n", optarg);
+				exit(1);
+			}
+			break;
+		case 'k':
+			key_fn = optarg;
+			break;
+		case 'i':
+			in_fn = optarg;
+			break;
+		case 'o':
+			out_fn = optarg;
+			break;
+		case 's':
+			md_alg = get_hash_alg(optarg);
+			if (md_alg < 0) {
+				ERROR("Invalid hash algorithm '%s'\n", optarg);
+				exit(1);
+			}
+			break;
+		case 'n':
+			align = get_image_align(optarg);
+			if (0 >= align) {
+				ERROR("Invalid alignment '%s'\n", optarg);
+				exit(1);
+			}
+			break;
+		case 'h':
+			print_help(argv[0], cmd_opt);
+			exit(0);
+		case '?':
+		default:
+			print_help(argv[0], cmd_opt);
+			exit(1);
+		}
+	}
+
+	if (!key_fn) {
+		ERROR("Key filename must not be NULL\n");
+		exit(1);
+	}
+
+	if (!in_fn) {
+		ERROR("Input filename must not be NULL\n");
+		exit(1);
+	}
+
+	if (!out_fn) {
+		ERROR("Output filename must not be NULL\n");
+		exit(1);
+	}
+
+	ret = sign_file(key_alg, key_fn, md_alg, in_fn, out_fn, (unsigned int)align);
+
+	CRYPTO_cleanup_all_ex_data();
+
+	return ret;
+}
diff --git a/tools/renesas/rzg_security_tools/sign_fw/src/sign.c b/tools/renesas/rzg_security_tools/sign_fw/src/sign.c
new file mode 100644
index 0000000..4d2ee67
--- /dev/null
+++ b/tools/renesas/rzg_security_tools/sign_fw/src/sign.c
@@ -0,0 +1,157 @@
+/*
+ * Copyright (c) 2021, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <openssl/evp.h>
+#include <openssl/pem.h>
+#include <stdio.h>
+#include <string.h>
+#include "debug.h"
+#include "sign.h"
+
+#define BUFFER_SIZE		256
+#define KEY_SIZE		16
+#define KEY_STRING_SIZE	32
+
+const EVP_MD *get_digest(int alg)
+{
+	switch (alg) {
+	case HASH_ALG_SHA256:
+		return EVP_sha256();
+	default:
+		return NULL;
+	}
+}
+
+static int rsa_sign(char *key_name, int md_alg, const char *ip_name,
+			const char *op_name, unsigned int align)
+{
+	FILE *ip_file = NULL;
+	FILE *op_file = NULL;
+	FILE *kp_file = NULL;
+	EVP_MD_CTX *ctx = NULL;
+	EVP_PKEY *pkey = NULL;
+	unsigned char data[BUFFER_SIZE];
+	unsigned char sign[BUFFER_SIZE];
+	size_t sig_size = BUFFER_SIZE;
+	int bytes, ret = 0;
+	unsigned long in_fsz, pad_sz;
+	
+	ip_file = fopen(ip_name, "rb");
+	if (ip_file == NULL) {
+		ERROR("Cannot read %s\n", ip_name);
+		ret = -1;
+		goto out;
+	}
+
+	op_file = fopen(op_name, "wb");
+	if (op_file == NULL) {
+		ERROR("Cannot write %s\n", op_name);
+		ret = -1;
+		goto out;
+	}
+
+	kp_file = fopen(key_name, "rb");
+	if (op_file == NULL) {
+		ERROR("Cannot read %s\n", ip_name);
+		ret = -1;
+		goto out;
+	}
+	
+	pkey = PEM_read_PrivateKey(kp_file, NULL, NULL, NULL);
+	if (pkey == NULL) {
+		ERROR("PEM_read_PrivateKey failed\n");
+		ret = -1;
+		goto out;
+	}
+	
+	if (BUFFER_SIZE < EVP_PKEY_size(pkey)) {
+		ERROR("EVP_PKEY_size failed\n");
+		ret = -1;
+		goto out;
+	}
+
+	ctx = EVP_MD_CTX_create();
+	if (ctx == NULL) {
+		ERROR("EVP_MD_CTX_create failed\n");
+		ret = -1;
+		goto out;
+	}
+
+	ret = EVP_DigestSignInit(ctx, NULL, get_digest(md_alg), NULL, pkey);
+	if (ret != 1) {
+		ERROR("EVP_DigestSignInit failed\n");
+		ret = -1;
+		goto out;
+	}
+	
+	in_fsz = 0;
+	while ((bytes = fread(data, 1, BUFFER_SIZE, ip_file)) != 0) {
+		ret = EVP_DigestSignUpdate(ctx, data, bytes);
+		if (ret != 1) {
+			ERROR("EVP_DigestSignUpdate failed\n");
+			ret = -1;
+			goto out;
+		}
+		in_fsz += fwrite(data, 1, bytes, op_file);
+	}
+	
+	memset(data, 0, BUFFER_SIZE);
+	pad_sz = ((in_fsz + (align - 1)) & (~(align - 1))) - in_fsz;
+	while (pad_sz > 0) { 
+		bytes = (pad_sz < BUFFER_SIZE) ? pad_sz : BUFFER_SIZE;
+		pad_sz -= bytes;
+		ret = EVP_DigestSignUpdate(ctx, data, bytes);
+		if (ret != 1) {
+			ERROR("EVP_DigestSignUpdate failed\n");
+			ret = -1;
+			goto out;
+		}
+		fwrite(data, 1, bytes, op_file);
+	}
+	
+	ret = EVP_DigestSignFinal(ctx, sign, &sig_size);
+	if (ret != 1) {
+		ERROR("EVP_DigestSignFinal failed\n");
+		ret = -1;
+		goto out;
+	}
+
+	fwrite(sign, 1, sig_size, op_file);
+	
+	EVP_MD_CTX_reset(ctx);
+
+out:
+	if (NULL != ctx)
+		EVP_MD_CTX_destroy(ctx);
+	if (NULL != pkey)
+		EVP_PKEY_free(pkey);
+	if (NULL != ip_file)
+		fclose(ip_file);
+	if (NULL != op_file)
+		fclose(op_file);
+	if (NULL != kp_file)
+		fclose(kp_file);
+
+	/*
+	 * EVP_* APIs returns 1 as success but signtool considers
+	 * 0 as success.
+	 */
+	if (ret == 1)
+		ret = 0;
+
+	return ret;
+}
+
+int sign_file(int key_alg, char *key_name, int md_alg, 
+		const char *ip_name, const char *op_name, unsigned int align)
+{
+	switch (key_alg) {
+	case KEY_ALG_RSA:
+		return rsa_sign(key_name, md_alg, ip_name, op_name, align);
+	default:
+		return -1;
+	}
+}
-- 
2.7.4
